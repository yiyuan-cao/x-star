/**
 * datatype definitions automatically generated by cstar compiler
 * extracted from [[ghost::datatype]] attributes in reverse.c
 * intended for use by reverse_test.c
 */

#include "reverse_datatype.h"
#include <stdio.h>
#include <stdlib.h>


// we can also use datatype99 to ease the process of generating this file
struct i32_list_block {
    enum { nil_tag, cons_tag } tag;
    union {
        struct {
            char list_nil_dummy;
        };
        struct {
            int32_t head;
            i32_list tail;
        };
    };
};

i32_list nil() {
    i32_list l = malloc(sizeof(struct i32_list_block));
    *l = (struct i32_list_block){.tag = nil_tag};
    return l;
}

i32_list cons(int32_t head, i32_list tail) {
    i32_list l = malloc(sizeof(struct i32_list_block));
    *l = (struct i32_list_block){.tag = cons_tag, .head = head, .tail = tail};
    return l;
}

int32_t head(i32_list l) { return l->head; }

i32_list tail(i32_list l) { return l->tail; }

bool is_nil(i32_list l) { return l->tag == nil_tag; }

bool is_cons(i32_list l) { return l->tag == cons_tag; }

bool i32_list_eq(i32_list l1, i32_list l2) {
    if (is_nil(l1) && is_nil(l2)) {
        return true;
    }
    if (is_cons(l1) && is_cons(l2)) {
        return (l1->head == l2->head) && i32_list_eq(l1->tail, l2->tail);
    }
    return false;
}

// debug only
void i32_list_print_aux(i32_list l) {
    if (is_nil(l)) {
        printf("nil");
    } else {
        printf("(cons %d ", l->head);
        i32_list_print_aux(l->tail);
        printf(")");
    }
}

void i32_list_print(i32_list l) {
    i32_list_print_aux(l);
    printf("\n");
}
