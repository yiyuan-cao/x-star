/**
 * datatype definitions automatically generated by cstar compiler
 * extracted from [[ghost::datatype]] attributes in reverse.c
 * intended for use by reverse_test.c
 */

#include "reverse_datatype.h"
#include "cstar.h"
#include <stdio.h>
#include <stdlib.h>
// we can also use datatype99 to ease the process of generating this file
struct list_block {
    enum { list_nil_tag, list_cons_tag } tag;
    union {
        struct {
            char list_nil_dummy;
        };
        struct {
            int list_cons_head;
            List list_cons_tail;
        };
    };
};

List list_nil() {
    List list = malloc(sizeof(struct list_block));
    *list = (struct list_block){.tag = list_nil_tag};
    return list;
}

List list_cons(Z head, List tail) {
    List list = malloc(sizeof(struct list_block));
    *list =
        (struct list_block){.tag = list_cons_tag, .list_cons_head = head, .list_cons_tail = tail};
    return list;
}

Z list_cons_head(List list) { return list->list_cons_head; }

List list_cons_tail(List list) { return list->list_cons_tail; }

Bool list_is_nil(List list) { return list->tag == list_nil_tag; }

Bool list_is_cons(List list) { return list->tag == list_cons_tag; }

Bool list_equal(List list1, List list2) {
    if (list_is_nil(list1) AND list_is_nil(list2)) {
        return true;
    }
    if (list_is_cons(list1) AND list_is_cons(list2)) {
        return list1->list_cons_head EQ list2->list_cons_head AND list_equal(list1->list_cons_tail,
                                                                             list2->list_cons_tail);
    }
    return false;
}

// debug only
void list_print_sexp(List list) {
    if (list_is_nil(list)) {
        printf("nil");
    } else {
        printf("(cons %d ", list_cons_head(list));
        list_print_sexp(list_cons_tail(list));
        printf(")");
    }
}

void list_println_sexp(List list) {
    list_print_sexp(list);
    printf("\n");
}
