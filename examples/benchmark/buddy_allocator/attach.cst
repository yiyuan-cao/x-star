#include "cstar.h"
#include "def.h"
#include "lemma.h"

#define HYP_MAX_ORDER 11
#define HYP_NO_ORDER 255
#define HYP_PAGE_SHIFT 12
#define HYP_PAGE_SIZE 4096

typedef unsigned char u8;
typedef unsigned short u16;
typedef unsigned int u32;
typedef unsigned long long u64;
typedef unsigned long long phys_addr_t;

u64 __hyp_vmemmap;

struct list_head
{
	struct list_head *next;
	struct list_head *prev;
};

struct hyp_pool
{
	struct list_head free_area[HYP_MAX_ORDER];
	u64 range_start;
	u64 range_end;
	u8 max_order;
};

struct hyp_page
{
	u16 refcount;
	u8 order;
	u8 flags;
};

#define hyp_vmemmap ((struct hyp_page *)__hyp_vmemmap)

#define __hyp_pa(virt)	((phys_addr_t)(virt) + hyp_physvirt_offset)
#define __hyp_va(phys)	((phys_addr_t)(phys) - hyp_physvirt_offset)
// void *hyp_phys_to_virt(phys_addr_t phys) { return __hyp_va(phys); }
// phys_addr_t hyp_virt_to_phys(void *addr) { return __hyp_pa(addr); }

#define hyp_phys_to_pfn(phys)	((phys) / HYP_PAGE_SIZE)
#define hyp_pfn_to_phys(pfn)	((phys_addr_t)((pfn) * HYP_PAGE_SIZE))
#define hyp_phys_to_page(phys)	(&hyp_vmemmap[hyp_phys_to_pfn(phys)])
#define hyp_virt_to_page(virt)	hyp_phys_to_page(__hyp_pa(virt))
#define hyp_virt_to_pfn(virt)	hyp_phys_to_pfn(__hyp_pa(virt))
#define hyp_page_to_pfn(page)	((struct hyp_page *)(page) - hyp_vmemmap)
#define hyp_page_to_phys(page)  hyp_pfn_to_phys((hyp_page_to_pfn(page)))
#define hyp_page_to_virt(page)	__hyp_va(hyp_page_to_phys(page))

// assmue auto exists elimination
// assmue auto facts elimination

static void __hyp_attach_page(struct hyp_pool *pool, struct hyp_page *pg)
	[[cstar::parameter(`l : ((num#num))list`)]]
	[[cstar::parameter(`dl : ((addr#addr)list)`)]]
	[[cstar::parameter(`hl : ((addr#addr)list)`)]]
	[[cstar::parameter(`pi : num`)]]
	[[cstar::parameter(`pref : num`)]]
	[[cstar::parameter(`porder : num`)]]
	[[cstar::parameter(`vmemmap : addr`)]]
	[[cstar::parameter(`start : num`)]]
	[[cstar::parameter(`end : num`)]]
	[[cstar::parameter(`len : num`)]]
	[[cstar::parameter(`max_order : num`)]]
	[[cstar::parameter(`NO_ORDER : num`)]]
	[[cstar::parameter(`REF_LIM : num`)]]
	[[cstar::parameter(`PAGE_SIZE : num`)]]
	[[cstar::parameter(`PTR_SIZE : num`)]]
	[[cstar::parameter(`LIST_HEAD_SIZE : num`)]]
	[[cstar::parameter(`MAX_ORDER : num`)]]
	[[cstar::require(`
		data_at(&"__hyp_vmemmap", Tptr, vmemmap) **
		hfact (pg = vmemmap + &(pi * 4)) ** hfact (pi < len) **
		hfact (pref = REF (nth l pi)) ** hfact (pref > 0) **
		hfact (porder = ORD (nth l pi)) ** hfact (~(porder = NO_ORDER)) **
		hfact (LENGTH l = len) **
		hfact (LENGTH dl = len) **
		hfact (LENGTH hl = max_order) **
		hfact (pure_const) **
		hfact (dlist_head pool l dl 0 max_order hl) **
		hfact (dlist_node pool (ifilter l) l dl hl start end dl) **
		(pool_const pool) **
		(dlist_head_repr pool 0 max_order hl) **
		(free_area_repr (ifilter l) start end l) **
		(free_area_head_repr (ifilter l) start end dl) **
		(store_pageinfo_array vmemmap start (i2id pi) (take l pi)) **
			hfact (~(porder = NO_ORDER) ==> (porder < max_order) && ((2 EXP porder) divides (i2id pi))) **
			hfact (pref < REF_LIM) **
			(data_at (vmemmap + &(pi * 4), Tushort, &0)) **
			(data_at ((vmemmap + &(pi * 4)) + &2, Tuchar, &porder)) **
			(undef_data_at ((vmemmap + &(pi * 4)) + &3, Tuchar)) **
		(store_pageinfo_array vmemmap (SUC (i2id pi)) end (rest l (SUC pi))) **
		(store_undef_array (i2vi pi) 0 (PAGE_SIZE * (2 EXP porder)) (PAGE_SIZE * (2 EXP porder)))
	`)]]
	[[cstar::ensure(`
		exists new_l new_dl new_hl.
			hfact (LENGTH new_l = len) **
			hfact (LENGTH new_dl = len) **
			hfact (LENGTH new_hl = max_order) **
			hfact (pure_const) **
			hfact (dlist_head pool_pre new_l new_dl 0 max_order new_hl) **
			hfact (dlist_node pool_pre (ifilter new_l) new_l new_dl new_hl start end new_dl) **
			(pool_const pool_pre) **
			(dlist_head_repr pool_pre 0 max_order new_hl) **
			(free_area_repr (ifilter new_l) start end new_l) **
			(free_area_head_repr (ifilter new_l) start end new_dl) **
			(store_pageinfo_array vmemmap start end new_l)
	`)]]
{
    [[cstar::assert(`
		data_at(&"pool", Tptr, pool_pre) **
		data_at(&"pg", Tptr, pg_pre) **
		data_at(&"__hyp_vmemmap", Tptr, vmemmap) **
		hfact (pure_const) **
		hfact (dlist_node pool_pre (ifilter l) l dl hl start end dl) **
		hfact (dlist_head pool_pre l dl 0 max_order hl) **
		hfact (LENGTH l = len) **
		hfact (LENGTH dl = len) **
		hfact (LENGTH hl = max_order) **
		hfact (pg_pre = vmemmap + &(pi * 4)) **
		hfact (pi < len) **
		hfact (~(porder = NO_ORDER)) **
		hfact (pref > 0) **
		hfact (pref = REF (nth l pi)) **
		hfact (porder = ORD (nth l pi)) **
		(pool_const pool_pre) **
		(dlist_head_repr pool_pre 0 max_order hl) **
		(free_area_repr (ifilter l) start end l) **
		(free_area_head_repr (ifilter l) start end dl) **
		(store_pageinfo_array vmemmap start (i2id pi) (take l pi)) **
			hfact (~(porder = NO_ORDER) ==> (porder < max_order) && ((2 EXP porder) divides (i2id pi))) ** 
			hfact (pref < REF_LIM) **
			(data_at (vmemmap + &(pi * 4), Tushort, &0)) **
			(data_at ((vmemmap + &(pi * 4)) + &2, Tuchar, &porder)) **
			(undef_data_at ((vmemmap + &(pi * 4)) + &3, Tuchar)) **
		(store_pageinfo_array vmemmap (SUC (i2id pi)) end (rest l (SUC pi))) **
		(store_undef_array (i2vi pi) 0 (PAGE_SIZE * (2 EXP porder)) (PAGE_SIZE * (2 EXP porder)))
    `)]];
	struct hyp_page *buddy = NULL;
    [[cstar::assert(`
		data_at(&"buddy", Tptr, &0) **
		data_at(&"pool", Tptr, pool_pre) **
		data_at(&"pg", Tptr, pg_pre) **
		data_at(&"__hyp_vmemmap", Tptr, vmemmap) **
		hfact (pure_const) **
		hfact (dlist_node pool_pre (ifilter l) l dl hl start end dl) **
		hfact (dlist_head pool_pre l dl 0 max_order hl) **
		hfact (LENGTH l = len) **
		hfact (LENGTH dl = len) **
		hfact (LENGTH hl = max_order) **
		hfact (pg_pre = vmemmap + &(pi * 4)) **
		hfact (pi < len) **
		hfact (~(porder = NO_ORDER)) **
		hfact (pref > 0) **
		hfact (pref = REF (nth l pi)) **
		hfact (porder = ORD (nth l pi)) **
		(pool_const pool_pre) **
		(dlist_head_repr pool_pre 0 max_order hl) **
		(free_area_repr (ifilter l) start end l) **
		(free_area_head_repr (ifilter l) start end dl) **
		(store_pageinfo_array vmemmap start (i2id pi) (take l pi)) **
			hfact (~(porder = NO_ORDER) ==> (porder < max_order) && ((2 EXP porder) divides (i2id pi))) ** 
			hfact (pref < REF_LIM) **
			(data_at (vmemmap + &(pi * 4), Tushort, &0)) **
			(data_at ((vmemmap + &(pi * 4)) + &2, Tuchar, &porder)) **
			(undef_data_at ((vmemmap + &(pi * 4)) + &3, Tuchar)) **
		(store_pageinfo_array vmemmap (SUC (i2id pi)) end (rest l (SUC pi))) **
		(store_undef_array (i2vi pi) 0 (PAGE_SIZE * (2 EXP porder)) (PAGE_SIZE * (2 EXP porder)))
    `)]];
	[[cstar::proof(
		/*	proof1 : 
				unfold pool_const;
				get data_at &"pool -> max_order";
				get data_at &"pg -> order";
		*/
		// __state = get_symbolic_state();
		{
			term fact = `pg_pre = vmemmap + &(pi * 4)`;
			thm data_at_pg_pre2order = use_fact_symm_rewrite(
				fact, `data_at ((vmemmap + &(pi * 4)) + &2, Tuchar, &(porder : num))`);
			thm pool_const_unfold = unfold(`pool_const pool_pre`, POOL_CONST_DEF);
			thm trans = create_trans_auto(
				(term[]){NULL}, (term[]){fact, NULL}, (thm[]){NULL}, 
				(thm[]){pool_const_unfold, data_at_pg_pre2order, NULL});
			trans = point_to_handler(trans, pg2order_axiom, `pg_pre : addr`, `&(porder : num)`);
			trans = point_to_handler(trans, pool2max_order_axiom, `pool_pre : addr`, `&(max_order : num)`);
			__transform = which_implies(__state, trans);
		}
		// set_symbolic_state(__transform);
	)]];
    [[cstar::assert(`
		data_at(&"buddy", Tptr, &0) **
		data_at(&"pool", Tptr, pool_pre) **
		data_at(&"pg", Tptr, pg_pre) **
		data_at(&"__hyp_vmemmap", Tptr, vmemmap) **
		hfact (pure_const) **
		hfact (dlist_node pool_pre (ifilter l) l dl hl start end dl) **
		hfact (dlist_head pool_pre l dl 0 max_order hl) **
		hfact (LENGTH l = len) **
		hfact (LENGTH dl = len) **
		hfact (LENGTH hl = max_order) **
		hfact (pg_pre = vmemmap + &(pi * 4)) **
		hfact (pi < len) **
		hfact (~(porder = NO_ORDER)) **
		hfact (pref > 0) **
		hfact (pref = REF (nth l pi)) **
		hfact (porder = ORD (nth l pi)) **
		data_at (pool_pre + &(LIST_HEAD_SIZE * MAX_ORDER), Tuint64, id2ph start) **
        data_at (pool_pre + &(LIST_HEAD_SIZE * MAX_ORDER + 8), Tuint64, id2ph end) **
        data_at (&"pool -> max_order", Tuchar, &max_order) **
		(dlist_head_repr pool_pre 0 max_order hl) **
		(free_area_repr (ifilter l) start end l) **
		(free_area_head_repr (ifilter l) start end dl) **
		(store_pageinfo_array vmemmap start (i2id pi) (take l pi)) **
			hfact (~(porder = NO_ORDER) ==> (porder < max_order) && ((2 EXP porder) divides (i2id pi))) ** 
			hfact (pref < REF_LIM) **
			(data_at (vmemmap + &(pi * 4), Tushort, &0)) **
			(data_at (&"pg -> order", Tuchar, &porder)) **
			(undef_data_at ((vmemmap + &(pi * 4)) + &3, Tuchar)) **
		(store_pageinfo_array vmemmap (SUC (i2id pi)) end (rest l (SUC pi))) **
		(store_undef_array (i2vi pi) 0 (PAGE_SIZE * (2 EXP porder)) (PAGE_SIZE * (2 EXP porder)))
    `)]];
	u8 order = pg -> order;
    [[cstar::assert(`
		data_at(&"order", Tuchar, &porder) **
		data_at(&"buddy", Tptr, &0) **
		data_at(&"pool", Tptr, pool_pre) **
		data_at(&"pg", Tptr, pg_pre) **
		data_at(&"__hyp_vmemmap", Tptr, vmemmap) **
		hfact (pure_const) **
		hfact (dlist_node pool_pre (ifilter l) l dl hl start end dl) **
		hfact (dlist_head pool_pre l dl 0 max_order hl) **
		hfact (LENGTH l = len) **
		hfact (LENGTH dl = len) **
		hfact (LENGTH hl = max_order) **
		hfact (pg_pre = vmemmap + &(pi * 4)) **
		hfact (pi < len) **
		hfact (~(porder = NO_ORDER)) **
		hfact (pref > 0) **
		hfact (pref = REF (nth l pi)) **
		hfact (porder = ORD (nth l pi)) **
		data_at (pool_pre + &(LIST_HEAD_SIZE * MAX_ORDER), Tuint64, id2ph start) **
        data_at (pool_pre + &(LIST_HEAD_SIZE * MAX_ORDER + 8), Tuint64, id2ph end) **
        data_at (&"pool -> max_order", Tuchar, &max_order) **
		(dlist_head_repr pool_pre 0 max_order hl) **
		(free_area_repr (ifilter l) start end l) **
		(free_area_head_repr (ifilter l) start end dl) **
		(store_pageinfo_array vmemmap start (i2id pi) (take l pi)) **
			hfact (~(porder = NO_ORDER) ==> (porder < max_order) && ((2 EXP porder) divides (i2id pi))) ** 
			hfact (pref < REF_LIM) **
			(data_at (vmemmap + &(pi * 4), Tushort, &0)) **
			(data_at (&"pg -> order", Tuchar, &porder)) **
			(undef_data_at ((vmemmap + &(pi * 4)) + &3, Tuchar)) **
		(store_pageinfo_array vmemmap (SUC (i2id pi)) end (rest l (SUC pi))) **
		(store_undef_array (i2vi pi) 0 (PAGE_SIZE * (2 EXP porder)) (PAGE_SIZE * (2 EXP porder)))
    `)]];
	pg -> order = HYP_NO_ORDER;
    [[cstar::assert(`
		data_at(&"order", Tuchar, &porder) **
		data_at(&"buddy", Tptr, &0) **
		data_at(&"pool", Tptr, pool_pre) **
		data_at(&"pg", Tptr, pg_pre) **
		data_at(&"__hyp_vmemmap", Tptr, vmemmap) **
		hfact (pure_const) **
		hfact (dlist_node pool_pre (ifilter l) l dl hl start end dl) **
		hfact (dlist_head pool_pre l dl 0 max_order hl) **
		hfact (LENGTH l = len) **
		hfact (LENGTH dl = len) **
		hfact (LENGTH hl = max_order) **
		hfact (pg_pre = vmemmap + &(pi * 4)) **
		hfact (pi < len) **
		hfact (~(porder = NO_ORDER)) **
		hfact (pref > 0) **
		hfact (pref = REF (nth l pi)) **
		hfact (porder = ORD (nth l pi)) **
		data_at (pool_pre + &(LIST_HEAD_SIZE * MAX_ORDER), Tuint64, id2ph start) **
        data_at (pool_pre + &(LIST_HEAD_SIZE * MAX_ORDER + 8), Tuint64, id2ph end) **
        data_at (&"pool -> max_order", Tuchar, &max_order) **
		(dlist_head_repr pool_pre 0 max_order hl) **
		(free_area_repr (ifilter l) start end l) **
		(free_area_head_repr (ifilter l) start end dl) **
		(store_pageinfo_array vmemmap start (i2id pi) (take l pi)) **
			hfact (~(porder = NO_ORDER) ==> (porder < max_order) && ((2 EXP porder) divides (i2id pi))) ** 
			hfact (pref < REF_LIM) **
			(data_at (vmemmap + &(pi * 4), Tushort, &0)) **
			(data_at (&"pg -> order", Tuchar, &HYP_NO_ORDER)) **
			(undef_data_at ((vmemmap + &(pi * 4)) + &3, Tuchar)) **
		(store_pageinfo_array vmemmap (SUC (i2id pi)) end (rest l (SUC pi))) **
		(store_undef_array (i2vi pi) 0 (PAGE_SIZE * (2 EXP porder)) (PAGE_SIZE * (2 EXP porder)))
    `)]];
	u8 max_order = pool -> max_order;
    [[cstar::assert(`
		data_at(&"max_order", Tuchar, &max_order) **
		data_at(&"order", Tuchar, &porder) **
		data_at(&"buddy", Tptr, &0) **
		data_at(&"pool", Tptr, pool_pre) **
		data_at(&"pg", Tptr, pg_pre) **
		data_at(&"__hyp_vmemmap", Tptr, vmemmap) **
		hfact (pure_const) **
		hfact (dlist_node pool_pre (ifilter l) l dl hl start end dl) **
		hfact (dlist_head pool_pre l dl 0 max_order hl) **
		hfact (LENGTH l = len) **
		hfact (LENGTH dl = len) **
		hfact (LENGTH hl = max_order) **
		hfact (pg_pre = vmemmap + &(pi * 4)) **
		hfact (pi < len) **
		hfact (~(porder = NO_ORDER)) **
		hfact (pref > 0) **
		hfact (pref = REF (nth l pi)) **
		hfact (porder = ORD (nth l pi)) **
		data_at (pool_pre + &(LIST_HEAD_SIZE * MAX_ORDER), Tuint64, id2ph start) **
        data_at (pool_pre + &(LIST_HEAD_SIZE * MAX_ORDER + 8), Tuint64, id2ph end) **
        data_at (&"pool -> max_order", Tuchar, &max_order) **
		(dlist_head_repr pool_pre 0 max_order hl) **
		(free_area_repr (ifilter l) start end l) **
		(free_area_head_repr (ifilter l) start end dl) **
		(store_pageinfo_array vmemmap start (i2id pi) (take l pi)) **
			hfact (~(porder = NO_ORDER) ==> (porder < max_order) && ((2 EXP porder) divides (i2id pi))) ** 
			hfact (pref < REF_LIM) **
			(data_at (vmemmap + &(pi * 4), Tushort, &0)) **
			(data_at (&"pg -> order", Tuchar, &HYP_NO_ORDER)) **
			(undef_data_at ((vmemmap + &(pi * 4)) + &3, Tuchar)) **
		(store_pageinfo_array vmemmap (SUC (i2id pi)) end (rest l (SUC pi))) **
		(store_undef_array (i2vi pi) 0 (PAGE_SIZE * (2 EXP porder)) (PAGE_SIZE * (2 EXP porder)))
    `)]];
	[[cstar::proof(
		/*	proof2 : 
				fold pool_const;
				rewrite back;
		*/
		// __state = get_symbolic_state();
		{
			term fact = `pg_pre = vmemmap + &(pi * 4)`;
			thm data_at_pg_pre2order = use_fact_rewrite(
				fact, `data_at (pg_pre + &2, Tuchar, &HYP_NO_ORDER)`);
			data_at_pg_pre2order = rewrite_after_ent(symm(NO_ORDER_DEF), data_at_pg_pre2order);
			thm pool_const_fold = fold(`pool_const pool_pre`, POOL_CONST_DEF);
			thm trans = create_trans_auto(
				(term[]){NULL}, (term[]){fact, NULL}, (thm[]){NULL}, 
				(thm[]){pool_const_fold, data_at_pg_pre2order, NULL});
			trans = point_to_handler(trans, pg2order_axiom, `pg_pre : addr`, `&(porder : num)`);
			trans = point_to_handler(trans, pool2max_order_axiom, `pool_pre : addr`, `&(max_order : num)`);
			__transform = which_implies(__state, trans);
		}
		// set_symbolic_state(__transform);
	)]];
    [[cstar::assert(`
		data_at(&"max_order", Tuchar, &max_order) **
		data_at(&"order", Tuchar, &porder) **
		data_at(&"buddy", Tptr, &0) **
		data_at(&"pool", Tptr, pool_pre) **
		data_at(&"pg", Tptr, pg_pre) **
		data_at(&"__hyp_vmemmap", Tptr, vmemmap) **
		hfact (pure_const) **
		hfact (dlist_node pool_pre (ifilter l) l dl hl start end dl) **
		hfact (dlist_head pool_pre l dl 0 max_order hl) **
		hfact (LENGTH l = len) **
		hfact (LENGTH dl = len) **
		hfact (LENGTH hl = max_order) **
		hfact (pg_pre = vmemmap + &(pi * 4)) **
		hfact (pi < len) **
		hfact (~(porder = NO_ORDER)) **
		hfact (pref > 0) **
		hfact (pref = REF (nth l pi)) **
		hfact (porder = ORD (nth l pi)) **
		(pool_const pool_pre) **
		(dlist_head_repr pool_pre 0 max_order hl) **
		(free_area_repr (ifilter l) start end l) **
		(free_area_head_repr (ifilter l) start end dl) **
		(store_pageinfo_array vmemmap start (i2id pi) (take l pi)) **
			hfact (~(porder = NO_ORDER) ==> (porder < max_order) && ((2 EXP porder) divides (i2id pi))) ** 
			hfact (pref < REF_LIM) **
			(data_at (vmemmap + &(pi * 4), Tushort, &0)) **
			(data_at ((vmemmap + &(pi * 4)) + &2, Tuchar, &NO_ORDER)) **
			(undef_data_at ((vmemmap + &(pi * 4)) + &3, Tuchar)) **
		(store_pageinfo_array vmemmap (SUC (i2id pi)) end (rest l (SUC pi))) **
		(store_undef_array (i2vi pi) 0 (PAGE_SIZE * (2 EXP porder)) (PAGE_SIZE * (2 EXP porder)))
    `)]];
	[[cstar::argument(
		`pi = i : num`,
		`order_v = porder : num`,
		`vmemmap = vmemmap : addr`,
		`PAGE_SIZE = PAGE_SIZE : num`
	)]]
	memset_page_zero(pg, order);
    [[cstar::assert(`
		data_at(&"max_order", Tuchar, &max_order) **
		data_at(&"order", Tuchar, &porder) **
		data_at(&"buddy", Tptr, &0) **
		data_at(&"pool", Tptr, pool_pre) **
		data_at(&"pg", Tptr, pg_pre) **
		data_at(&"__hyp_vmemmap", Tptr, vmemmap) **
		hfact (pure_const) **
		hfact (dlist_node pool_pre (ifilter l) l dl hl start end dl) **
		hfact (dlist_head pool_pre l dl 0 max_order hl) **
		hfact (LENGTH l = len) **
		hfact (LENGTH dl = len) **
		hfact (LENGTH hl = max_order) **
		hfact (pg_pre = vmemmap + &(pi * 4)) **
		hfact (pi < len) **
		hfact (~(porder = NO_ORDER)) **
		hfact (pref > 0) **
		hfact (pref = REF (nth l pi)) **
		hfact (porder = ORD (nth l pi)) **
		(pool_const pool_pre) **
		(dlist_head_repr pool_pre 0 max_order hl) **
		(free_area_repr (ifilter l) start end l) **
		(free_area_head_repr (ifilter l) start end dl) **
		(store_pageinfo_array vmemmap start (i2id pi) (take l pi)) **
			hfact (~(porder = NO_ORDER) ==> (porder < max_order) && ((2 EXP porder) divides (i2id pi))) ** 
			hfact (pref < REF_LIM) **
			(data_at (vmemmap + &(pi * 4), Tushort, &0)) **
			(data_at ((vmemmap + &(pi * 4)) + &2, Tuchar, &NO_ORDER)) **
			(undef_data_at ((vmemmap + &(pi * 4)) + &3, Tuchar)) **
		(store_pageinfo_array vmemmap (SUC (i2id pi)) end (rest l (SUC pi))) **
		(store_zero_array (i2vi pi) 0 (PAGE_SIZE * (2 EXP porder)) (PAGE_SIZE * (2 EXP porder)))
    `)]];
	[[cstar::proof(
		/*	proof3 : RESIDUAL PROOF 
				fold store_pageinfo_array;
				conversion : l -> inv_l := modified l pi (0, NO_ORDER)
					dlist_node / dlist_head / LENGTH / ORD / REF
					free_area_repr / free_area_head_repr;
		*/
		// __state = get_symbolic_state();
		{
			term v = `(0, NO_ORDER) : num#num`;
			term l = `l : (num#num)list`;
			term pi = `pi : num`;
			term ifilterl = `ifilter l`;

		// facts
			term fact_llen = `LENGTH (l : (num#num)list) = len`;
			term fact_pi_l_len = `pi < len : num`;
			term fact_ref = `pref = REF (nth l pi)`;
			term fact_ref_pos = `pref > 0`;
			term fact_ref_lim = `pref < REF_LIM`;
			term fact_ord = `porder == ORD (nth l pi)`;
			term fact_ord_cond = `~(porder = NO_ORDER) ==> (porder < max_order) && ((2 EXP porder) divides (i2id pi))`;
			term fact_ord_norm = `~(porder = NO_ORDER)`;
			term fact_pc = `pure_const`;
			term fact_dn = `dlist_node pool_pre (ifilter l) l dl hl start end dl`;
			term fact_dh = `dlist_head pool_pre l dl 0 max_order hl`;

			thm start_end = conjunct1(rewrite_rule(PURE_CONST_DEF, assume(fact_pc)));
			thm pi_l_llen = rewrite_rule(symm(assume(fact_llen)), assume(fact_pi_l_len));
			thm order_fact = mp(assume(fact_ord_cond), assume(fact_ord_norm));
			thm order_lim = conjunct1(order_fact);
			thm order_align = conjunct2(order_fact);
			thm ar1 = arith_rule(`! a : num. a > 0 ==> ~(a = 0)`);
			thm fh_neg = simp(rewrite_list((thm[]){
				FREE_HEAD_DEF, symm(assume(fact_ref)), 
				mp(ar1, assume(fact_ref_pos)), NULL
			}, `~free_head (nth l pi)`));
			thm ifl = simp(rewrite_list((thm[]){
				IFILTER_DEF, i2id2i(), fh_neg, NULL
			}, `~((ifilter l) (i2id pi))`));
			thm fh_eq = simp(rewrite_list((thm[]){
				fh_neg, FREE_HEAD_DEF, ORD_DEF, NULL
			}, `free_head (0, NO_ORDER) == free_head (nth l pi)`));
		// LENGTH inv_l == len
			thm invl_len = specs(modified_len(), (term[]){l, pi, v, NULL});
			invl_len = trans(invl_len, assume(fact_llen));
		// REF (nth inv_l pi) == 0
			thm ref = simp(rewrite_list((thm[]){
				mp(modified_nth(), pi_l_llen), REF_DEF, NULL
			}, `REF (nth (modified l pi (0,NO_ORDER)) pi) = 0`));
		// ORD (nth inv_l pi) == NO_ORDER
			thm ord = simp(rewrite_list((thm[]){
				mp(modified_nth(), pi_l_llen), ORD_DEF, NULL
			}, `ORD (nth (modified l pi (0,NO_ORDER)) pi) = NO_ORDER`));
		// ifilter l == ifilter inv_l
			thm ifl_inv = mps(filter_inv(), (thm[]){pi_l_llen, fh_eq, NULL});
		// dlist_node pool_pre (ifilter inv_l) inv_l dl hl start end dl
			thm dn = mps(dn_inv(), (thm[]){pi_l_llen, fh_neg, assume(fact_dn), NULL});
			dn = once_rewrite_rule(ifl_inv, spec(v, dn));
		// dlist_head pool_pre inv_l dl 0 max_order hl
			thm dh = mps(dh_inv(), (thm[]){pi_l_llen, fh_neg, assume(fact_dh), NULL});
			dh = spec(v, dh);

		// free_area_repr (ifilter l) start end l |--
		// free_area_repr (ifilter inv_l) start end inv_l
			thm ar2 = arith_rule(`start < end ==> start <= end`);
			thm far = mps(specs(far_inv(), (term[]){l, pi, v, ifilterl, NULL}), (thm[]){
				mp(ar2, start_end), LEN_DEF, assume(fact_pi_l_len), 
				symm(assume(fact_llen)), ifl, NULL
			});
			far = eq2ent(rewrite_rhs(ifl_inv, far));
		// free_area_head_repr (ifilter l) start end dl |--
		// free_area_head_repr (ifilter inv_l) start end dl
			thm fahr = eq2ent(once_rewrite(ifl_inv, `free_area_head_repr (ifilter l) start end dl`));
		// store_pageinfo_array
			thm ar3 = arith_rule(`0 < 65536`);
			term spa_obj = `store_pageinfo_array vmemmap start end (modified l pi (0,NO_ORDER))`;
			thm spa = break_spa_at_i(spa_obj, assume(fact_pi_l_len), symm(invl_len), start_end);
			spa = rewrite_list_rhs((thm[]){
				mp(modified_nth(), pi_l_llen),
				mp(modified_taken(), pi_l_llen),
				mp(modified_restn(), pi_l_llen),
				REF_DEF, ORD_DEF, REF_LIM_DEF, 
				ar3, htrue_elim_left, hsep_assoc, NULL
			}, spa);
			spa = eq2ent(symm(spa));

			thm trans = create_trans_auto(
				(term[]){fact_llen, fact_ref, fact_ref_pos, fact_ref_lim, fact_ord, fact_ord_cond, fact_dn, fact_dh, NULL},
				(term[]){fact_pi_l_len, fact_ord_norm, fact_pc, NULL},
				(thm[]){order_lim, order_align, invl_len, ref, ord, dn, dh, NULL},
				(thm[]){far, fahr, spa, NULL}
			);
			__transform = which_implies(__state, trans);
		}
		// set_symbolic_state(__transform);
	)]];
	[[cstar::assert(`
		data_at(&"max_order", Tuchar, &max_order) **
		data_at(&"order", Tuchar, &porder) **
		data_at(&"buddy", Tptr, &0) **
		data_at(&"pool", Tptr, pool_pre) **
		data_at(&"pg", Tptr, pg_pre) **
		data_at(&"__hyp_vmemmap", Tptr, vmemmap) **
		hfact (pure_const) **
		hfact (dlist_node pool_pre (ifilter (modified l pi (0, NO_ORDER))) (modified l pi (0, NO_ORDER)) dl hl start end dl) **
		hfact (dlist_head pool_pre (modified l pi (0, NO_ORDER)) dl 0 max_order hl) **
		hfact (LENGTH (modified l pi (0, NO_ORDER)) = len) **
		hfact (LENGTH dl = len) **
		hfact (LENGTH hl = max_order) **
		hfact (pg_pre = vmemmap + &(pi * 4)) **
		hfact (pi < len) **
		hfact (~(porder = NO_ORDER)) **
   		hfact (porder < max_order) **
   		hfact (2 EXP porder divides i2id pi) **
		hfact (ORD (nth (modified l pi (0, NO_ORDER)) pi) == NO_ORDER) **
		hfact (REF (nth (modified l pi (0, NO_ORDER)) pi) == 0) **
		(pool_const pool_pre) **
		(dlist_head_repr pool_pre 0 max_order hl) **
		(free_area_repr (ifilter (modified l pi (0, NO_ORDER))) start end (modified l pi (0, NO_ORDER))) **
		(free_area_head_repr (ifilter (modified l pi (0, NO_ORDER))) start end dl) **
		(store_pageinfo_array vmemmap start end (modified l pi (0, NO_ORDER))) **
		(store_zero_array (i2vi pi) 0 (PAGE_SIZE * (2 EXP porder)) (PAGE_SIZE * (2 EXP porder)))
    `)]];
	[[cstar::argument(
		`pi = i : num`,
		`order_v = porder : num`,
		`vmemmap = vmemmap : addr`,
		`l = (modified l pi (0, NO_ORDER)) : (num#num)list`,
		`start = start : num`,
		`end = end : num`,
		`len = len : num`
	)]]
	buddy = __find_buddy_avail(pool, pg, order);
    [[cstar::assert(`
	exists buddy_v bi.
		hfact ((buddy_v = &0) ||
			~(bi = pi) &&
			(buddy_v = vmemmap + &(bi * 4)) &&
			(bi < len) &&
			(REF (nth (modified l pi (0, NO_ORDER)) bi) = 0) &&
			(ORD (nth (modified l pi (0, NO_ORDER)) bi) = porder) &&
			((2 EXP (SUC porder)) divides (i2id (MIN pi bi))) &&
			(abs (&pi - &bi) = &(2 EXP porder))) **
		data_at(&"max_order", Tuchar, &max_order) **
		data_at(&"order", Tuchar, &porder) **
		data_at(&"buddy", Tptr, buddy_v) **
		data_at(&"pool", Tptr, pool_pre) **
		data_at(&"pg", Tptr, pg_pre) **
		data_at(&"__hyp_vmemmap", Tptr, vmemmap) **
		hfact (pure_const) **
		hfact (dlist_node pool_pre (ifilter (modified l pi (0, NO_ORDER))) (modified l pi (0, NO_ORDER)) dl hl start end dl) **
		hfact (dlist_head pool_pre (modified l pi (0, NO_ORDER)) dl 0 max_order hl) **
		hfact (LENGTH (modified l pi (0, NO_ORDER)) = len) **
		hfact (LENGTH dl = len) **
		hfact (LENGTH hl = max_order) **
		hfact (pg_pre = vmemmap + &(pi * 4)) **
		hfact (pi < len) **
		hfact (~(porder = NO_ORDER)) **
   		hfact (porder < max_order) **
   		hfact (2 EXP porder divides i2id pi) **
		hfact (ORD (nth (modified l pi (0, NO_ORDER)) pi) == NO_ORDER) **
		hfact (REF (nth (modified l pi (0, NO_ORDER)) pi) == 0) **
		(pool_const pool_pre) **
		(dlist_head_repr pool_pre 0 max_order hl) **
		(free_area_repr (ifilter (modified l pi (0, NO_ORDER))) start end (modified l pi (0, NO_ORDER))) **
		(free_area_head_repr (ifilter (modified l pi (0, NO_ORDER))) start end dl) **
		(store_pageinfo_array vmemmap start end (modified l pi (0, NO_ORDER))) **
		(store_zero_array (i2vi pi) 0 (PAGE_SIZE * (2 EXP porder)) (PAGE_SIZE * (2 EXP porder)))
    `)]];
	[[cstar::proof(
		/*	proof4 : 
				existentialization;
		*/
		// __state = get_symbolic_state();
		{
			thm trans = spec(__state, hentail_refl);
			trans = hexists_intro_auto(trans, `modified l pi (0,NO_ORDER) = inv_l`);
			trans = hexists_intro_auto(trans, `dl = inv_dl : (addr#addr)list`);
			trans = hexists_intro_auto(trans, `hl = inv_hl : (addr#addr)list`);
			trans = hexists_intro_auto(trans, `pi = i : num`);
			trans = hexists_intro_auto(trans, `porder = ord : num`);
			trans = hexists_intro_auto(trans, `pg_pre = pg_v : addr`);
			__transform = trans;
		}
		// set_symbolic_state(__transform);
	)]];
    [[cstar::invariant(`
	exists buddy_v bi inv_l inv_dl inv_hl i ord pg_v.
		hfact ((buddy_v = &0) ||
			~(bi = i) &&
			(buddy_v = vmemmap + &(bi * 4)) &&
			(bi < len) &&
			(REF (nth inv_l bi) = 0) &&
			(ORD (nth inv_l bi) = ord) &&
			((2 EXP (SUC ord)) divides (i2id (MIN i bi))) &&
			(abs (&i - &bi) = &(2 EXP ord))) **
		data_at(&"max_order", Tuchar, &max_order) **
		data_at(&"order", Tuchar, &ord) **
		data_at(&"buddy", Tptr, buddy_v) **
		data_at(&"pool", Tptr, pool_pre) **
		data_at(&"pg", Tptr, pg_v) **
		data_at(&"__hyp_vmemmap", Tptr, vmemmap) **
		hfact (pure_const) **
		hfact (dlist_node pool_pre (ifilter inv_l) inv_l inv_dl inv_hl start end inv_dl) **
		hfact (dlist_head pool_pre inv_l inv_dl 0 max_order inv_hl) **
		hfact (LENGTH inv_l = len) **
		hfact (LENGTH inv_dl = len) **
		hfact (LENGTH inv_hl = max_order) **
		hfact (pg_v = vmemmap + &(i * 4)) **
		hfact (i < len) **
		hfact (~(ord = NO_ORDER)) **
		hfact (ord < max_order) **
		hfact ((2 EXP ord) divides (i2id i)) **
		hfact (ORD (nth inv_l i) = NO_ORDER) **
		hfact (REF (nth inv_l i) = 0) **
		(pool_const pool_pre) **
		(dlist_head_repr pool_pre 0 max_order inv_hl) **
		(free_area_repr (ifilter inv_l) start end inv_l) **
		(free_area_head_repr (ifilter inv_l) start end inv_dl) **
		(store_pageinfo_array vmemmap start end inv_l) **
		(store_zero_array (i2vi i) 0 (PAGE_SIZE * (2 EXP ord)) (PAGE_SIZE * (2 EXP ord)))
    `)]]
	while ((order + 1) < max_order && buddy != 0)
	{
		[[cstar::assert(`
		exists buddy_v bi inv_l inv_dl inv_hl i ord pg_v.
			hfact (&ord + &1 < &max_order && ~(buddy_v = &0)) **
			hfact ((buddy_v = &0) ||
				~(bi = i) &&
				(buddy_v = vmemmap + &(bi * 4)) &&
				(bi < len) &&
				(REF (nth inv_l bi) = 0) &&
				(ORD (nth inv_l bi) = ord) &&
				((2 EXP (SUC ord)) divides (i2id (MIN i bi))) &&
				(abs (&i - &bi) = &(2 EXP ord))) **
			data_at(&"max_order", Tuchar, &max_order) **
			data_at(&"order", Tuchar, &ord) **
			data_at(&"buddy", Tptr, buddy_v) **
			data_at(&"pool", Tptr, pool_pre) **
			data_at(&"pg", Tptr, pg_v) **
			data_at(&"__hyp_vmemmap", Tptr, vmemmap) **
			hfact (pure_const) **
			hfact (dlist_node pool_pre (ifilter inv_l) inv_l inv_dl inv_hl start end inv_dl) **
			hfact (dlist_head pool_pre inv_l inv_dl 0 max_order inv_hl) **
			hfact (LENGTH inv_l = len) **
			hfact (LENGTH inv_dl = len) **
			hfact (LENGTH inv_hl = max_order) **
			hfact (pg_v = vmemmap + &(i * 4)) **
			hfact (i < len) **
			hfact (~(ord = NO_ORDER)) **
			hfact (ord < max_order) **
			hfact ((2 EXP ord) divides (i2id i)) **
			hfact (ORD (nth inv_l i) = NO_ORDER) **
			hfact (REF (nth inv_l i) = 0) **
			(pool_const pool_pre) **
			(dlist_head_repr pool_pre 0 max_order inv_hl) **
			(free_area_repr (ifilter inv_l) start end inv_l) **
			(free_area_head_repr (ifilter inv_l) start end inv_dl) **
			(store_pageinfo_array vmemmap start end inv_l) **
			(store_zero_array (i2vi i) 0 (PAGE_SIZE * (2 EXP ord)) (PAGE_SIZE * (2 EXP ord)))
		`)]];
		[[cstar::proof(
			/*	proof5 : 
					use buddy != 0 get facts;
					split store_pageinfo_array at bi;
			*/
			// __state = get_symbolic_state();
			{
				term fact_inv = `&(ord : num) + &1 < &max_order && ~(buddy_v = &0)`;
				term fact_buddy = `
					(buddy_v = &0) ||
					~(bi = i) &&
					(buddy_v = vmemmap + &(bi * 4)) &&
					(bi < len) &&
					(REF (nth inv_l bi) = 0) &&
					(ORD (nth inv_l bi) = ord) &&
					((2 EXP (SUC ord)) divides (i2id (MIN i bi))) &&
					(abs(&i - &bi) = &(2 EXP ord))`;
				thm bfact[9];
				bfact[0] = conjunct1(assume(fact_inv));
				thm bfacts = rewrite_rule(conjunct2(assume(fact_inv)), assume(fact_buddy));
				int i = 1;
				while(i <= 7)
				{
					bfact[i] = conjunctn(bfacts, i);
					i = i + 1;
				}
				bfact[8] = NULL;

				term fact_invl_len = `LENGTH (inv_l : (num#num)list) = len`;
				term fact_pc = `pure_const`;
				thm start_end = conjunct1(rewrite_rule(PURE_CONST_DEF, assume(fact_pc)));
				term spa_obj = `store_pageinfo_array vmemmap start end inv_l`;
				thm split_eq = break_spa_at_i(spa_obj, bfact[3], symm(assume(fact_invl_len)), start_end);
				thm data_at_buddy_v2order = rewrite(
					symm(bfact[2]), `data_at ((vmemmap + &(bi * 4)) + &2, Tuchar, &(porder : num))`);
				thm spa = eq2ent(rewrite_list_rhs((thm[]){data_at_buddy_v2order, bfact[4], bfact[5], NULL}, split_eq));

				thm trans = create_trans_auto(
					(term[]){fact_inv, fact_buddy, NULL}, 
					(term[]){fact_invl_len, fact_pc, NULL},
					bfact, (thm[]){spa, NULL});
				trans = point_to_handler(trans, buddy2order_axiom, `buddy_v : addr`, `&(ord : num)`);
				__transform = which_implies(__state, trans);
			}
			// set_symbolic_state(__transform);
		)]];
		[[cstar::assert(`
		exists buddy_v bi inv_l (inv_dl : (addr#addr)list) (inv_hl : (addr#addr)list) i ord pg_v.
			hfact (&ord + &1 < &max_order) **
			hfact (~(bi = i)) **
			hfact (buddy_v = vmemmap + &(bi * 4)) **
			hfact (bi < len) **
			hfact (REF (nth inv_l bi) = 0) **
			hfact (ORD (nth inv_l bi) = ord) **
			hfact ((2 EXP (SUC ord)) divides (i2id (MIN i bi))) **
			hfact (abs (&i - &bi) = &(2 EXP ord)) **
			data_at(&"max_order", Tuchar, &max_order) **
			data_at(&"order", Tuchar, &ord) **
			data_at(&"buddy", Tptr, buddy_v) **
			data_at(&"pool", Tptr, pool_pre) **
			data_at(&"pg", Tptr, pg_v) **
			data_at(&"__hyp_vmemmap", Tptr, vmemmap) **
			hfact (pure_const) **
			hfact (dlist_node pool_pre (ifilter inv_l) inv_l inv_dl inv_hl start end inv_dl) **
			hfact (dlist_head pool_pre inv_l inv_dl 0 max_order inv_hl) **
			hfact (LENGTH inv_l = len) **
			hfact (LENGTH inv_dl = len) **
			hfact (LENGTH inv_hl = max_order) **
			hfact (pg_v = vmemmap + &(i * 4)) **
			hfact (i < len) **
			hfact (~(ord = NO_ORDER)) **
			hfact (ord < max_order) **
			hfact ((2 EXP ord) divides (i2id i)) **
			hfact (ORD (nth inv_l i) = NO_ORDER) **
			hfact (REF (nth inv_l i) = 0) **
			(pool_const pool_pre) **
			(dlist_head_repr pool_pre 0 max_order inv_hl) **
			(free_area_repr (ifilter inv_l) start end inv_l) **
			(free_area_head_repr (ifilter inv_l) start end inv_dl) **
			(store_pageinfo_array vmemmap start (i2id bi) (take inv_l bi)) **
				hfact (~(ord = NO_ORDER) ==> (ord < max_order) && ((2 EXP ord) divides (i2id bi))) **
				hfact (0 < REF_LIM) **
				(data_at (vmemmap + &(bi * 4), Tushort, &0)) **
				(data_at (&"buddy -> order", Tuchar, &ord)) **
				(undef_data_at ((vmemmap + &(bi * 4)) + &3, Tuchar)) **
			(store_pageinfo_array vmemmap (SUC (i2id bi)) end (rest inv_l (SUC bi))) **
			(store_zero_array (i2vi i) 0 (PAGE_SIZE * (2 EXP ord)) (PAGE_SIZE * (2 EXP ord)))
		`)]];
		[[cstar::argument(
			`pi = bi : num`,
			`order_v = ord : num`,
			`vmemmap = vmemmap : addr`,
			`l = inv_l : (num#num)list`,
			`dl = inv_dl : (addr#addr)list`,
			`hl = inv_hl : (addr#addr)list`,
			`start = start : num`,
			`end = end : num`,
			`len = len : num`,
			`max_order = max_order : num`,
			`NO_ORDER = NO_ORDER : num`,
			`PTR_SIZE = PTR_SIZE : num`
		)]]
		page_remove_from_list_pool(pool, buddy);
		[[cstar::assert(`
		exists new_l new_dl new_hl buddy_v bi inv_l (inv_dl : (addr#addr)list) (inv_hl : (addr#addr)list) i ord pg_v.
			hfact (new_l = modified inv_l bi (0, NO_ORDER)) **
			hfact (LENGTH new_l = len) **
			hfact (LENGTH new_dl = len) **
			hfact (LENGTH new_hl = max_order) **
			hfact (&ord + &1 < &max_order) **
			hfact (~(bi = i)) **
			hfact (buddy_v = vmemmap + &(bi * 4)) **
			hfact (bi < len) **
			hfact (REF (nth inv_l bi) = 0) **
			hfact (ORD (nth inv_l bi) = ord) **
			hfact ((2 EXP (SUC ord)) divides (i2id (MIN i bi))) **
			hfact (abs (&i - &bi) = &(2 EXP ord)) **
			data_at(i2vi bi, Tptr, &0) **
			data_at(i2vi bi + &PTR_SIZE, Tptr, &0) **
			data_at(&"max_order", Tuchar, &max_order) **
			data_at(&"order", Tuchar, &ord) **
			data_at(&"buddy", Tptr, buddy_v) **
			data_at(&"pool", Tptr, pool_pre) **
			data_at(&"pg", Tptr, pg_v) **
			data_at(&"__hyp_vmemmap", Tptr, vmemmap) **
			hfact (pure_const) **
			hfact (dlist_node pool_pre (ifilter new_l) new_l new_dl new_hl start end new_dl) **
			hfact (dlist_head pool_pre new_l new_dl 0 max_order new_hl) **
			hfact (LENGTH inv_l = len) **
			hfact (LENGTH inv_dl = len) **
			hfact (LENGTH inv_hl = max_order) **
			hfact (pg_v = vmemmap + &(i * 4)) **
			hfact (i < len) **
			hfact (~(ord = NO_ORDER)) **
			hfact (ord < max_order) **
			hfact ((2 EXP ord) divides (i2id i)) **
			hfact (ORD (nth inv_l i) = NO_ORDER) **
			hfact (REF (nth inv_l i) = 0) **
			(pool_const pool_pre) **
			(dlist_head_repr pool_pre 0 max_order new_hl) **
			(free_area_repr (ifilter inv_l) start end inv_l) **
			(free_area_head_repr (ifilter new_l) start end new_dl) **
			(store_pageinfo_array vmemmap start end inv_l) **
			(store_zero_array (i2vi i) 0 (PAGE_SIZE * (2 EXP ord)) (PAGE_SIZE * (2 EXP ord)))
		`)]];
		buddy -> order = HYP_NO_ORDER;
		[[cstar::assert(`
		exists new_l new_dl new_hl buddy_v bi inv_l (inv_dl : (addr#addr)list) (inv_hl : (addr#addr)list) i ord pg_v.
			hfact (new_l = modified inv_l bi (0, NO_ORDER)) **
			hfact (LENGTH new_l = len) **
			hfact (LENGTH new_dl = len) **
			hfact (LENGTH new_hl = max_order) **
			hfact (&ord + &1 < &max_order) **
			hfact (~(bi = i)) **
			hfact (buddy_v = vmemmap + &(bi * 4)) **
			hfact (bi < len) **
			hfact (REF (nth inv_l bi) = 0) **
			hfact (ORD (nth inv_l bi) = ord) **
			hfact ((2 EXP (SUC ord)) divides (i2id (MIN i bi))) **
			hfact (abs (&i - &bi) = &(2 EXP ord)) **
			data_at(i2vi bi, Tptr, &0) **
			data_at(i2vi bi + &PTR_SIZE, Tptr, &0) **
			data_at(&"max_order", Tuchar, &max_order) **
			data_at(&"order", Tuchar, &ord) **
			data_at(&"buddy", Tptr, buddy_v) **
			data_at(&"pool", Tptr, pool_pre) **
			data_at(&"pg", Tptr, pg_v) **
			data_at(&"__hyp_vmemmap", Tptr, vmemmap) **
			hfact (pure_const) **
			hfact (dlist_node pool_pre (ifilter new_l) new_l new_dl new_hl start end new_dl) **
			hfact (dlist_head pool_pre new_l new_dl 0 max_order new_hl) **
			hfact (LENGTH inv_l = len) **
			hfact (LENGTH inv_dl = len) **
			hfact (LENGTH inv_hl = max_order) **
			hfact (pg_v = vmemmap + &(i * 4)) **
			hfact (i < len) **
			hfact (~(ord = NO_ORDER)) **
			hfact (ord < max_order) **
			hfact ((2 EXP ord) divides (i2id i)) **
			hfact (ORD (nth inv_l i) = NO_ORDER) **
			hfact (REF (nth inv_l i) = 0) **
			(pool_const pool_pre) **
			(dlist_head_repr pool_pre 0 max_order new_hl) **
			(free_area_repr (ifilter inv_l) start end inv_l) **
			(free_area_head_repr (ifilter new_l) start end new_dl) **
			(store_pageinfo_array vmemmap start (i2id bi) (take inv_l bi)) **
				hfact (~(ord = NO_ORDER) ==> (ord < max_order) && ((2 EXP ord) divides (i2id bi))) **
				hfact (0 < REF_LIM) **
				(data_at (vmemmap + &(bi * 4), Tushort, &0)) **
				(data_at (&"buddy -> order", Tuchar, &HYP_NO_ORDER)) **
				(undef_data_at ((vmemmap + &(bi * 4)) + &3, Tuchar)) **
			(store_pageinfo_array vmemmap (SUC (i2id bi)) end (rest inv_l (SUC bi))) **
			(store_zero_array (i2vi i) 0 (PAGE_SIZE * (2 EXP ord)) (PAGE_SIZE * (2 EXP ord)))
		`)]];
		pg = min(pg, buddy);
		[[cstar::assert(`
		exists new_pg new_l new_dl new_hl buddy_v bi inv_l (inv_dl : (addr#addr)list) (inv_hl : (addr#addr)list) i ord pg_v.
			hfact (new_pg = min pg_v buddy_v) **
			hfact (new_l = modified inv_l bi (0, NO_ORDER)) **
			hfact (LENGTH new_l = len) **
			hfact (LENGTH new_dl = len) **
			hfact (LENGTH new_hl = max_order) **
			hfact (&ord + &1 < &max_order) **
			hfact (~(bi = i)) **
			hfact (buddy_v = vmemmap + &(bi * 4)) **
			hfact (bi < len) **
			hfact (REF (nth inv_l bi) = 0) **
			hfact (ORD (nth inv_l bi) = ord) **
			hfact ((2 EXP (SUC ord)) divides (i2id (MIN i bi))) **
			hfact (abs (&i - &bi) = &(2 EXP ord)) **
			data_at(i2vi bi, Tptr, &0) **
			data_at(i2vi bi + &PTR_SIZE, Tptr, &0) **
			data_at(&"max_order", Tuchar, &max_order) **
			data_at(&"order", Tuchar, &ord) **
			data_at(&"buddy", Tptr, buddy_v) **
			data_at(&"pool", Tptr, pool_pre) **
			data_at(&"pg", Tptr, new_pg) **
			data_at(&"__hyp_vmemmap", Tptr, vmemmap) **
			hfact (pure_const) **
			hfact (dlist_node pool_pre (ifilter new_l) new_l new_dl new_hl start end new_dl) **
			hfact (dlist_head pool_pre new_l new_dl 0 max_order new_hl) **
			hfact (LENGTH inv_l = len) **
			hfact (LENGTH inv_dl = len) **
			hfact (LENGTH inv_hl = max_order) **
			hfact (pg_v = vmemmap + &(i * 4)) **
			hfact (i < len) **
			hfact (~(ord = NO_ORDER)) **
			hfact (ord < max_order) **
			hfact ((2 EXP ord) divides (i2id i)) **
			hfact (ORD (nth inv_l i) = NO_ORDER) **
			hfact (REF (nth inv_l i) = 0) **
			(pool_const pool_pre) **
			(dlist_head_repr pool_pre 0 max_order new_hl) **
			(free_area_repr (ifilter inv_l) start end inv_l) **
			(free_area_head_repr (ifilter new_l) start end new_dl) **
			(store_pageinfo_array vmemmap start (i2id bi) (take inv_l bi)) **
				hfact (~(ord = NO_ORDER) ==> (ord < max_order) && ((2 EXP ord) divides (i2id bi))) **
				hfact (0 < REF_LIM) **
				(data_at (vmemmap + &(bi * 4), Tushort, &0)) **
				(data_at (&"buddy -> order", Tuchar, &HYP_NO_ORDER)) **
				(undef_data_at ((vmemmap + &(bi * 4)) + &3, Tuchar)) **
			(store_pageinfo_array vmemmap (SUC (i2id bi)) end (rest inv_l (SUC bi))) **
			(store_zero_array (i2vi i) 0 (PAGE_SIZE * (2 EXP ord)) (PAGE_SIZE * (2 EXP ord)))
		`)]];		
        order = order + 1;
		[[cstar::assert(`
		exists new_pg new_l new_dl new_hl buddy_v bi inv_l (inv_dl : (addr#addr)list) (inv_hl : (addr#addr)list) i ord pg_v.
			hfact (new_pg = min pg_v buddy_v) **
			hfact (new_l = modified inv_l bi (0, NO_ORDER)) **
			hfact (LENGTH new_l = len) **
			hfact (LENGTH new_dl = len) **
			hfact (LENGTH new_hl = max_order) **
			hfact (&ord + &1 < &max_order) **
			hfact (~(bi = i)) **
			hfact (buddy_v = vmemmap + &(bi * 4)) **
			hfact (bi < len) **
			hfact (REF (nth inv_l bi) = 0) **
			hfact (ORD (nth inv_l bi) = ord) **
			hfact ((2 EXP (SUC ord)) divides (i2id (MIN i bi))) **
			hfact (abs (&i - &bi) = &(2 EXP ord)) **
			data_at(i2vi bi, Tptr, &0) **
			data_at(i2vi bi + &PTR_SIZE, Tptr, &0) **
			data_at(&"max_order", Tuchar, &max_order) **
			data_at(&"order", Tuchar, &ord + &1) **
			data_at(&"buddy", Tptr, buddy_v) **
			data_at(&"pool", Tptr, pool_pre) **
			data_at(&"pg", Tptr, new_pg) **
			data_at(&"__hyp_vmemmap", Tptr, vmemmap) **
			hfact (pure_const) **
			hfact (dlist_node pool_pre (ifilter new_l) new_l new_dl new_hl start end new_dl) **
			hfact (dlist_head pool_pre new_l new_dl 0 max_order new_hl) **
			hfact (LENGTH inv_l = len) **
			hfact (LENGTH inv_dl = len) **
			hfact (LENGTH inv_hl = max_order) **
			hfact (pg_v = vmemmap + &(i * 4)) **
			hfact (i < len) **
			hfact (~(ord = NO_ORDER)) **
			hfact (ord < max_order) **
			hfact ((2 EXP ord) divides (i2id i)) **
			hfact (ORD (nth inv_l i) = NO_ORDER) **
			hfact (REF (nth inv_l i) = 0) **
			(pool_const pool_pre) **
			(dlist_head_repr pool_pre 0 max_order new_hl) **
			(free_area_repr (ifilter inv_l) start end inv_l) **
			(free_area_head_repr (ifilter new_l) start end new_dl) **
			(store_pageinfo_array vmemmap start (i2id bi) (take inv_l bi)) **
				hfact (~(ord = NO_ORDER) ==> (ord < max_order) && ((2 EXP ord) divides (i2id bi))) **
				hfact (0 < REF_LIM) **
				(data_at (vmemmap + &(bi * 4), Tushort, &0)) **
				(data_at (&"buddy -> order", Tuchar, &HYP_NO_ORDER)) **
				(undef_data_at ((vmemmap + &(bi * 4)) + &3, Tuchar)) **
			(store_pageinfo_array vmemmap (SUC (i2id bi)) end (rest inv_l (SUC bi))) **
			(store_zero_array (i2vi i) 0 (PAGE_SIZE * (2 EXP ord)) (PAGE_SIZE * (2 EXP ord)))
		`)]];
		[[cstar::proof(
			/*	proof6 : RESIDUAL PROOF 
					merge store_pageinfo_array;
					update free_area_head_repr;
					merge store_zero_array;
					new_i := MIN i bi;
					new_ord = ord + 1;
					derive facts of new_i;
					existentialization new_i new_ord;
			*/
			// __state = get_symbolic_state();
			{
				term v = `(0, NO_ORDER) : num#num`;
				term invl = `inv_l : (num#num)list`;
				term bi = `bi : num`;
				term ifilterl = `ifilter (modified inv_l bi (0, NO_ORDER))`;
			// facts
				term fact_newl = `new_l = modified inv_l bi (0, NO_ORDER)`;
				term fact_invl_len = `LENGTH (inv_l : (num#num)list) = len`;
				term fact_newl_len = `LENGTH (new_l : (num#num)list) = len`;
				term fact_npg = `(new_pg : addr) = min (pg_v : addr) (buddy_v : addr)`;
				term fact_pg_v = `pg_v = vmemmap + &(i * 4)`;
				term fact_buddy_v = `buddy_v = vmemmap + &(bi * 4)`;
				term fact_i_l_len = `i < len`;
				term fact_bi_l_len = `bi < len`;
				term fact_uneq = `~((bi : num) = i)`;
				term fact_diff = `abs (&(i : num) - &(bi : num)) = &(2 EXP (ord : num))`;
				term fact_ref = `REF (nth inv_l bi) = 0`;
				term fact_ord = `ORD (nth inv_l bi) = ord`;
				term fact_i_ref = `REF (nth inv_l i) = 0`;
				term fact_i_ord = `ORD (nth inv_l i) = NO_ORDER`;
				term fact_ord_norm = `~((ord : num) = NO_ORDER)`;
				term fact_new_ord = `&(ord : num) + &1 < &max_order`;
				term fact_pc = `pure_const`;

				thm pc = rewrite_rule(PURE_CONST_DEF, assume(fact_pc));
				thm start_end = conjunct1(pc);
				thm maxord_lim = conjunct1(conjunct2(pc));
				thm bi_l_len = rewrite_rule(symm(assume(fact_invl_len)), assume(fact_bi_l_len));
				thm ni_l_len = mps(
					arith_rule(`i < len ==> bi < len ==> MIN i bi < len`),
					(thm[]){assume(fact_i_l_len), assume(fact_bi_l_len), NULL}
				);

			// merge spa
				term spa_obj = `store_pageinfo_array vmemmap start end new_l`;
				thm spa = break_spa_at_i(spa_obj, assume(fact_bi_l_len), symm(assume(fact_newl_len)), start_end);
				thm data_at_buddy_v2order = rewrite(
					assume(fact_buddy_v), `data_at (buddy_v + &2, Tuchar, &HYP_NO_ORDER)`);
				thm ar1 = arith_rule(`0 < 65536`);
				spa = rewrite_list_rhs((thm[]){
					assume(fact_newl), 
					mp(modified_nth(), bi_l_len), 
					mp(modified_taken(), bi_l_len),
					mp(modified_restn(), bi_l_len),
					REF_DEF, ORD_DEF, REF_LIM_DEF, ar1, NO_ORDER_DEF, 
					symm(data_at_buddy_v2order), htrue_elim_left, hsep_assoc, NULL
				}, spa);
				spa = eq2ent(symm(spa));

			// new_pg == vmemmap + &(MIN i bi * 4)
				term MIN_ob = `MIN i bi`;
				thm MIN_def = rewrite(get_theorem("MIN"), MIN_ob);
				thm equation = rewrite_rule_list((thm[]){
					get_theorem("INT_MIN"), assume(fact_buddy_v), 
					assume(fact_pg_v), NULL
				}, assume(fact_npg));
				term casep = `(i : num) <= bi`;
				term casen = mk_comb(`~`, casep);
				thm ar2 = arith_rule(`i <= bi ==> (i * 4) <= (bi * 4)`);
				thm ar3 = arith_rule(`! a b. a <= b ==> vmemmap + &a <= vmemmap + &b`);
				thm MINp = symm(rewrite_rule(assume(casep), MIN_def));
				thm minp = mp(ar3, mp(ar2, assume(casep)));
				thm thp = rewrite_rule(minp, equation);
				thp = once_rewrite_rule(MINp, thp);
				thm ar4 = arith_rule(`~(i <= bi) ==> ~((i * 4) <= (bi * 4))`);
				thm ar5 = arith_rule(`! a b. ~(a <= b) ==> ~(vmemmap + &a <= vmemmap + &b)`);
				thm MINn = symm(rewrite_rule(assume(casen), MIN_def));
				thm minn = mp(ar5, mp(ar4, assume(casen)));
				thm thn = rewrite_rule(minn, equation);
				thn = once_rewrite_rule(MINn, thn);
				thm new_pg = merge_disj_cases(casep, thp, thn);

			// far + sza
				thm subth = simp(rewrite_list((thm[]){
					IFILTER_DEF, FREE_HEAD_DEF, i2id2i(), 
					mp(modified_nth(), bi_l_len), ORD_DEF, REF_DEF, NULL
				}, `~(ifilter (modified inv_l bi (0, NO_ORDER)) (i2id bi))`));
				thm ar9 = arith_rule(`start < end ==> start <= end`);
				thm far_inv_ = mps(specs(far_inv(), (term[]){invl, bi, v, ifilterl, NULL}), (thm[]){
					mp(ar9, start_end), LEN_DEF, assume(fact_bi_l_len), 
					symm(assume(fact_invl_len)), subth, NULL
				});

				thm ar6 = arith_rule(`start <= start + i`);
				thm ar7 = arith_rule(`bi < end - start ==> start + bi < end`);
				thm ar8 = arith_rule(`(start + bi) - start = bi`);
				thm prec1 = arith_rule(`start <= start`);
				thm prec2 = rewrite_rule(symm(I2ID_DEF), ar6);
				thm prec3 = rewrite_rule(symm(I2ID_DEF), mp(ar7, rewrite_rule(LEN_DEF, assume(fact_bi_l_len))));
				thm prec4 = bi_l_len;
				thm prec5 = simp(rewrite_list((thm[]){
					IFILTER_DEF, i2id2i(), FREE_HEAD_DEF, 
					assume(fact_ref), assume(fact_ord), 
					assume(fact_ord_norm), NULL
				}, `ifilter inv_l (i2id bi)`));
				thm prec6 = symm(rewrite_list((thm[]){
					I2ID_DEF, ar8, NULL
				}, `nth (inv_l : (num#num)list) ((i2id bi) - start)`));
				thm far = mps(far_split(), (thm[]){prec1, prec2, prec3, prec4, prec5, prec6, NULL});
				far = rewrite_list_rhs((thm[]){symm(I2VI_DEF), far_inv_, symm(assume(fact_newl)), NULL}, far);

				term head = ` \
					data_at(i2vi bi, Tptr, &0) ** \
					data_at(i2vi bi + &PTR_SIZE, Tptr, &0)`;
				term iblock = `store_zero_array (i2vi i) 0 (PAGE_SIZE * (2 EXP ord)) (PAGE_SIZE * (2 EXP ord))`;
				thm far_sza = rewrite_rule_list((thm[]){
					hsep_assoc, merge_head_body_axiom(), assume(fact_ord), NULL
				}, spec(head, mp(hsep_cancel_right, eq2ent(far))));
				far_sza = rewrite_rule_list((thm[]){
					hsep_assoc, mp(sza_merge(), assume(fact_diff)), NULL
				}, spec(iblock, mp(hsep_cancel_right, far_sza)));

			// order facts
				thm ar10 = arith_rule(`&(ord : num) + &1 < &max_order ==> SUC ord < max_order`);
				thm ar11 = arith_rule(`!ord : num. ord < max_order ==> max_order <= 11 ==> ~(ord = HYP_NO_ORDER)`);
				thm ord_lim = mp(ar10, assume(fact_new_ord));
				thm ord_norm = mps(ar11, (thm[]){ord_lim, rewrite_rule(MAX_ORDER_DEF, maxord_lim), NULL});
				ord_norm = rewrite_rule(symm(NO_ORDER_DEF), ord_norm);

			// ORD REF of nth new_l new_i
				term goal_ord = `ORD (nth new_l (MIN i bi))`;
				term goal_ref = `REF (nth new_l (MIN i bi))`;

				thm ar12 = arith_rule(`~((bi : num) = i) ==> ~(i = bi)`);
				thm pfact = rewrite_rhs(assume(casep), rewrite(get_theorem("MIN"), MIN_ob));
				thm modified_mth_ = mps(modified_mth(), (thm[]){bi_l_len, mp(ar12, assume(fact_uneq)), NULL});
				thm *thl1 = (thm[]){pfact, assume(fact_newl), modified_mth_, NULL};
				thm thp_ord = rewrite_rhs(assume(fact_i_ord), rewrite_list(thl1, goal_ord));
				thm thp_ref = rewrite_rhs(assume(fact_i_ref), rewrite_list(thl1, goal_ref));

				thm nfact = rewrite_rhs(assume(casen), rewrite(get_theorem("MIN"), MIN_ob));
				thm modified_nth_ = mp(modified_nth(), bi_l_len);
				thm *thl2 = (thm[]){nfact, assume(fact_newl), modified_nth_, NULL};
				thm thn_ord = rewrite_rhs(ORD_DEF, rewrite_list(thl2, goal_ord));
				thm thn_ref = rewrite_rhs(REF_DEF, rewrite_list(thl2, goal_ref));

				thm th_ord = merge_disj_cases(casep, thp_ord, thn_ord);
				thm th_ref = merge_disj_cases(casep, thp_ref, thn_ref);

				term fact_neg1 = `~(ord == NO_ORDER) ==> ord < max_order && 2 EXP ord divides i2id bi`;
				term fact_neg2 = `LENGTH (inv_dl : (addr#addr)list) == len`;
				term fact_neg3 = `LENGTH (inv_hl : (addr#addr)list) == max_order`;
				term fact_neg4 = `(ord : num) < max_order`;
				term fact_neg5 = `2 EXP (ord : num) divides i2id (i : num)`;
				term fact_neg6 = `0 < REF_LIM`;

				term *cfactl = (term[]){fact_newl, fact_invl_len, fact_npg, fact_pg_v, fact_buddy_v, 
					fact_i_l_len, fact_bi_l_len, fact_uneq, fact_diff, fact_ref, fact_ord, 
					fact_i_ref, fact_i_ord, fact_ord_norm, fact_new_ord, 
					fact_neg1, fact_neg2, fact_neg3, fact_neg4, fact_neg5, fact_neg6, NULL};
				term *kfactl = (term[]){fact_newl_len, fact_pc, NULL};
				thm *pthl = (thm[]){new_pg, ni_l_len, ord_lim, ord_norm, th_ord, th_ref, NULL};
				thm *hthl = (thm[]){spa, far_sza, NULL};
				thm trans = create_trans_auto(cfactl, kfactl, pthl, hthl);
				trans = point_to_handler(trans, buddy2order_axiom, `buddy_v : addr`, `&(ord : num)`);
				trans = which_implies(__state, trans);

				thm ar13 = arith_rule(`&(ord : num) + &1 = &(SUC ord)`);
				trans = rewrite_after_ent(ar13, trans);
				trans = hexists_intro_auto(trans, `MIN (i : num) (bi : num) = (new_i : num)`);
				trans = hexists_intro_auto(trans, `SUC ord = new_ord : num`);
				__transform = trans;
			}
			// set_symbolic_state(__transform);
		)]];
		[[cstar::assert(`
		exists new_pg new_l new_dl new_hl (buddy_v : addr) (bi : num) (inv_l : (num#num)list) (inv_dl : (addr#addr)list) (inv_hl : (addr#addr)list) (i : num) (ord : num) (pg_v : addr) new_i new_ord.
			data_at(&"max_order", Tuchar, &max_order) **
			data_at(&"order", Tuchar, &new_ord) **
			data_at(&"buddy", Tptr, buddy_v) **
			data_at(&"pool", Tptr, pool_pre) **
			data_at(&"pg", Tptr, new_pg) **
			data_at(&"__hyp_vmemmap", Tptr, vmemmap) **
			hfact (pure_const) **
			hfact (dlist_node pool_pre (ifilter new_l) new_l new_dl new_hl start end new_dl) **
			hfact (dlist_head pool_pre new_l new_dl 0 max_order new_hl) **
			hfact (LENGTH new_l = len) **
			hfact (LENGTH new_dl = len) **
			hfact (LENGTH new_hl = max_order) **
			hfact (new_pg = vmemmap + &(new_i * 4)) **
			hfact (new_i < len) **
			hfact (~(new_ord = NO_ORDER)) **
			hfact (new_ord < max_order) **
			hfact ((2 EXP new_ord) divides (i2id new_i)) **
			hfact (ORD (nth new_l new_i) = NO_ORDER) **
			hfact (REF (nth new_l new_i) = 0) **
			(pool_const pool_pre) **
			(dlist_head_repr pool_pre 0 max_order new_hl) **
			(free_area_repr (ifilter new_l) start end new_l) **
			(free_area_head_repr (ifilter new_l) start end new_dl) **
			(store_pageinfo_array vmemmap start end new_l) **
			(store_zero_array (i2vi new_i) 0 (PAGE_SIZE * (2 EXP new_ord)) (PAGE_SIZE * (2 EXP new_ord)))
		`)]];
		[[cstar::argument(
			`pi = new_i : num`,
			`order_v = new_ord : num`,
			`vmemmap = vmemmap : addr`,
			`l = new_l : (num#num)list`,
			`start = start : num`,
			`end = end : num`,
			`len = len : num`
		)]]
		buddy = __find_buddy_avail(pool, pg, order);
		[[cstar::assert(`
		exists new_buddy new_bi new_pg new_l new_dl new_hl (buddy_v : addr) (bi : num) (inv_l : (num#num)list) (inv_dl : (addr#addr)list) (inv_hl : (addr#addr)list) (i : num) (ord : num) (pg_v : addr) new_i new_ord.
			hfact ((new_buddy = &0) ||
				~(new_bi = new_i) &&
				(new_buddy = vmemmap + &(new_bi * 4)) &&
				(new_bi < len) &&
				(REF (nth new_l new_bi) = 0) &&
				(ORD (nth new_l new_bi) = new_ord) &&
				((2 EXP (SUC new_ord)) divides (i2id (MIN new_i new_bi))) &&
				(abs (&new_i - &new_bi) = &(2 EXP new_ord))) **
			data_at(&"max_order", Tuchar, &max_order) **
			data_at(&"order", Tuchar, &new_ord) **
			data_at(&"buddy", Tptr, new_buddy) **
			data_at(&"pool", Tptr, pool_pre) **
			data_at(&"pg", Tptr, new_pg) **
			data_at(&"__hyp_vmemmap", Tptr, vmemmap) **
			hfact (pure_const) **
			hfact (dlist_node pool_pre (ifilter new_l) new_l new_dl new_hl start end new_dl) **
			hfact (dlist_head pool_pre new_l new_dl 0 max_order new_hl) **
			hfact (LENGTH new_l = len) **
			hfact (LENGTH new_dl = len) **
			hfact (LENGTH new_hl = max_order) **
			hfact (new_pg = vmemmap + &(new_i * 4)) **
			hfact (new_i < len) **
			hfact (~(new_ord = NO_ORDER)) **
			hfact (new_ord < max_order) **
			hfact ((2 EXP new_ord) divides (i2id new_i)) **
			hfact (ORD (nth new_l new_i) = NO_ORDER) **
			hfact (REF (nth new_l new_i) = 0) **
			(pool_const pool_pre) **
			(dlist_head_repr pool_pre 0 max_order new_hl) **
			(free_area_repr (ifilter new_l) start end new_l) **
			(free_area_head_repr (ifilter new_l) start end new_dl) **
			(store_pageinfo_array vmemmap start end new_l) **
			(store_zero_array (i2vi new_i) 0 (PAGE_SIZE * (2 EXP new_ord)) (PAGE_SIZE * (2 EXP new_ord)))
		`)]];
	}
	[[cstar::assert(`
	exists pg_v ord i inv_l inv_dl inv_hl buddy_v bi.
		hfact (~(&ord + &1 < &max_order && ~(buddy_v = &0))) **
		hfact ((buddy_v = &0) ||
			~(bi = i) &&
			(buddy_v = vmemmap + &(bi * 4)) &&
			(bi < len) &&
			(REF (nth inv_l bi) = 0) &&
			(ORD (nth inv_l bi) = ord) &&
			((2 EXP (SUC ord)) divides (i2id (MIN i bi))) &&
			(abs (&i - &bi) = &(2 EXP ord))) **
		data_at(&"max_order", Tuchar, &max_order) **
		data_at(&"order", Tuchar, &ord) **
		data_at(&"buddy", Tptr, buddy_v) **
		data_at(&"pool", Tptr, pool_pre) **
		data_at(&"pg", Tptr, pg_v) **
		data_at(&"__hyp_vmemmap", Tptr, vmemmap) **
		hfact (pure_const) **
		hfact (dlist_node pool_pre (ifilter inv_l) inv_l inv_dl inv_hl start end inv_dl) **
		hfact (dlist_head pool_pre inv_l inv_dl 0 max_order inv_hl) **
		hfact (LENGTH inv_l = len) **
		hfact (LENGTH inv_dl = len) **
		hfact (LENGTH inv_hl = max_order) **
		hfact (pg_v = vmemmap + &(i * 4)) **
		hfact (i < len) **
		hfact (~(ord = NO_ORDER)) **
		hfact (ord < max_order) **
		hfact ((2 EXP ord) divides (i2id i)) **
		hfact (ORD (nth inv_l i) = NO_ORDER) **
		hfact (REF (nth inv_l i) = 0) **
		(pool_const pool_pre) **
		(dlist_head_repr pool_pre 0 max_order inv_hl) **
		(free_area_repr (ifilter inv_l) start end inv_l) **
		(free_area_head_repr (ifilter inv_l) start end inv_dl) **
		(store_pageinfo_array vmemmap start end inv_l) **
		(store_zero_array (i2vi i) 0 (PAGE_SIZE * (2 EXP ord)) (PAGE_SIZE * (2 EXP ord)))
    `)]];
	[[cstar::proof(
		/*	proof7 : 
				split store_pageinfo_array at i;
		*/
		// __state = get_symbolic_state();
		{
			term fact_i_l_len = `i < len`;
			term fact_pg_v = `(pg_v : addr) = vmemmap + &(i * 4)`;
			term fact_invl_len = `LENGTH (inv_l : (num#num)list) = len`;
			term fact_ord = `ORD (nth (inv_l : (num#num)list) i) = NO_ORDER`;
			term fact_ref = `REF (nth (inv_l : (num#num)list) i) = 0`;
			term fact_pc = `pure_const`;

			thm start_end = conjunct1(rewrite_rule(PURE_CONST_DEF, assume(fact_pc)));

			term spa_obj = `store_pageinfo_array vmemmap start end inv_l`;
			thm split = break_spa_at_i(spa_obj, assume(fact_i_l_len), symm(assume(fact_invl_len)), start_end);
			thm data_at_pg_v_order = rewrite(
				symm(assume(fact_pg_v)), `data_at ((vmemmap + &(i * 4)) + &2, Tuchar, &NO_ORDER)`);
			thm ar = arith_rule(`0 < 65536`);
			thm spa = eq2ent(rewrite_list_rhs((thm[]){
				assume(fact_ord), 
				assume(fact_ref), 
				data_at_pg_v_order, 
				REF_LIM_DEF, ar, 
				htrue_elim_left, 
				hsep_assoc, NULL
			}, split));

			term *kfactl = (term[]){fact_i_l_len, fact_ord, fact_ref, fact_invl_len, fact_pg_v, fact_pc, NULL};
			thm trans = create_trans_auto((term[]){NULL}, kfactl, (thm[]){NULL}, (thm[]){spa, NULL});
			trans = point_to_handler(trans, pg2order_axiom, `pg_v : addr`, `&NO_ORDER`);
			
			__transform = which_implies(__state, trans);
		}
		// set_symbolic_state(__transform);
	)]];
	[[cstar::assert(`
	exists pg_v ord i inv_l inv_dl inv_hl buddy_v bi.
		hfact (~(&ord + &1 < &max_order && ~(buddy_v = &0))) **
		hfact ((buddy_v = &0) ||
			~(bi = i) &&
			(buddy_v = vmemmap + &(bi * 4)) &&
			(bi < len) &&
			(REF (nth inv_l bi) = 0) &&
			(ORD (nth inv_l bi) = ord) &&
			((2 EXP (SUC ord)) divides (i2id (MIN i bi))) &&
			(abs (&i - &bi) = &(2 EXP ord))) **
		data_at(&"max_order", Tuchar, &max_order) **
		data_at(&"order", Tuchar, &ord) **
		data_at(&"buddy", Tptr, buddy_v) **
		data_at(&"pool", Tptr, pool_pre) **
		data_at(&"pg", Tptr, pg_v) **
		data_at(&"__hyp_vmemmap", Tptr, vmemmap) **
		hfact (pure_const) **
		hfact (dlist_node pool_pre (ifilter inv_l) inv_l inv_dl inv_hl start end inv_dl) **
		hfact (dlist_head pool_pre inv_l inv_dl 0 max_order inv_hl) **
		hfact (LENGTH inv_l = len) **
		hfact (LENGTH inv_dl = len) **
		hfact (LENGTH inv_hl = max_order) **
		hfact (pg_v = vmemmap + &(i * 4)) **
		hfact (i < len) **
		hfact (~(ord = NO_ORDER)) **
		hfact (ord < max_order) **
		hfact ((2 EXP ord) divides (i2id i)) **
		hfact (ORD (nth inv_l i) = NO_ORDER) **
		hfact (REF (nth inv_l i) = 0) **
		(pool_const pool_pre) **
		(dlist_head_repr pool_pre 0 max_order inv_hl) **
		(free_area_repr (ifilter inv_l) start end inv_l) **
		(free_area_head_repr (ifilter inv_l) start end inv_dl) **
		(store_pageinfo_array vmemmap start (i2id i) (take inv_l i)) **
			(data_at (vmemmap + &(i * 4), Tushort, &0)) **
			(data_at (&"pg -> order", Tuchar, &NO_ORDER)) **
			(undef_data_at ((vmemmap + &(i * 4)) + &3, Tuchar)) **
		(store_pageinfo_array vmemmap (SUC (i2id i)) end (rest inv_l (SUC i))) **
		(store_zero_array (i2vi i) 0 (PAGE_SIZE * (2 EXP ord)) (PAGE_SIZE * (2 EXP ord)))
    `)]];
	pg -> order = order;
	[[cstar::assert(`
	exists pg_v ord i inv_l inv_dl inv_hl buddy_v bi.
		hfact (~(&ord + &1 < &max_order && ~(buddy_v = &0))) **
		hfact ((buddy_v = &0) ||
			~(bi = i) &&
			(buddy_v = vmemmap + &(bi * 4)) &&
			(bi < len) &&
			(REF (nth inv_l bi) = 0) &&
			(ORD (nth inv_l bi) = ord) &&
			((2 EXP (SUC ord)) divides (i2id (MIN i bi))) &&
			(abs (&i - &bi) = &(2 EXP ord))) **
		data_at(&"max_order", Tuchar, &max_order) **
		data_at(&"order", Tuchar, &ord) **
		data_at(&"buddy", Tptr, buddy_v) **
		data_at(&"pool", Tptr, pool_pre) **
		data_at(&"pg", Tptr, pg_v) **
		data_at(&"__hyp_vmemmap", Tptr, vmemmap) **
		hfact (pure_const) **
		hfact (dlist_node pool_pre (ifilter inv_l) inv_l inv_dl inv_hl start end inv_dl) **
		hfact (dlist_head pool_pre inv_l inv_dl 0 max_order inv_hl) **
		hfact (LENGTH inv_l = len) **
		hfact (LENGTH inv_dl = len) **
		hfact (LENGTH inv_hl = max_order) **
		hfact (pg_v = vmemmap + &(i * 4)) **
		hfact (i < len) **
		hfact (~(ord = NO_ORDER)) **
		hfact (ord < max_order) **
		hfact ((2 EXP ord) divides (i2id i)) **
		hfact (ORD (nth inv_l i) = NO_ORDER) **
		hfact (REF (nth inv_l i) = 0) **
		(pool_const pool_pre) **
		(dlist_head_repr pool_pre 0 max_order inv_hl) **
		(free_area_repr (ifilter inv_l) start end inv_l) **
		(free_area_head_repr (ifilter inv_l) start end inv_dl) **
		(store_pageinfo_array vmemmap start (i2id i) (take inv_l i)) **
			(data_at (vmemmap + &(i * 4), Tushort, &0)) **
			(data_at (&"pg -> order", Tuchar, &ord)) **
			(undef_data_at ((vmemmap + &(i * 4)) + &3, Tuchar)) **
		(store_pageinfo_array vmemmap (SUC (i2id i)) end (rest inv_l (SUC i))) **
		(store_zero_array (i2vi i) 0 (PAGE_SIZE * (2 EXP ord)) (PAGE_SIZE * (2 EXP ord)))
    `)]];
	[[cstar::proof(
		/*	proof8 : RESIDUAL PROOF 
				merge store_pageinfo_array;
				break store_zero_array;
				update free_area_head_repr;
		*/
		// __state = get_symbolic_state();
		{
			term fact_ilen = `i < len`;
			term fact_invl_len = `LENGTH (inv_l : (num#num)list) = len`;
			term fact_pg_v = `(pg_v : addr) = vmemmap + &(i * 4)`;
			term fact_ref = `REF (nth (inv_l : (num#num)list) i) = 0`;
			term fact_ord = `ORD (nth (inv_l : (num#num)list) i) = NO_ORDER`;
			term fact_ord_lim = `(ord : num) < max_order`;
			term fact_ord_norm = `~(ord = NO_ORDER)`;
			term fact_ord_align = `(2 EXP ord) divides (i2id i)`;
			term fact_pc = `pure_const`;

			thm start_end = conjunct1(rewrite_rule(PURE_CONST_DEF, assume(fact_pc)));
			thm i_l_len = rewrite_rule(symm(assume(fact_invl_len)), assume(fact_ilen));
			thm newl_len = trans(specs(modified_len(), (term[]){
				`inv_l : (num#num)list`,
				`i : num`,
				`(0, ord) : num#num`,
				NULL
			}), assume(fact_invl_len));

		// split spa
			term spa_obj = `store_pageinfo_array vmemmap start end (modified inv_l i (0, ord))`;
			thm split = break_spa_at_i(spa_obj, assume(fact_ilen), symm(newl_len), start_end);
			thm data_at_pg_v2order = rewrite(
				assume(fact_pg_v), `data_at (pg_v + &2, Tuchar, &(ord : num))`);
			thm ar1 = arith_rule(`0 < 65536`);
			thm spa = rewrite_list_rhs((thm[]){
				assume(fact_ord), assume(fact_ref), 
				mp(modified_nth(), i_l_len), 
				mp(modified_taken(), i_l_len), 
				mp(modified_restn(), i_l_len), 
				ORD_DEF, REF_DEF, symm(data_at_pg_v2order),
				assume(fact_ord_lim), assume(fact_ord_align), 
				REF_LIM_DEF, ar1, htrue_elim_left, hsep_assoc, NULL
			}, split);
			spa = eq2ent(symm(spa));

		// far sza
			thm ar2 = arith_rule(`start <= start + i`);
			thm ar3 = arith_rule(`bi < end - start ==> start + bi < end`);
			thm ar4 = arith_rule(`(start + i) - start = i`);
			thm *thl1 = (thm[]){I2ID_DEF, ar4, NULL};
			thm prec1 = arith_rule(`start <= start`);
			thm prec2 = rewrite_rule(symm(I2ID_DEF), ar2);
			thm prec3 = rewrite_rule(symm(I2ID_DEF), mp(ar3, rewrite_rule(LEN_DEF, assume(fact_ilen))));
			thm prec4 = i_l_len;
			thm prec5 = simp(rewrite_list((thm[]){
				IFILTER_DEF, i2id2i(), FREE_HEAD_DEF, 
				assume(fact_ord), assume(fact_ord), NULL
			}, `~(ifilter inv_l (i2id i))`));
			thm prec6 = assume(fact_ord_norm);
			thm prec7 = symm(rewrite_list(thl1, `nth (inv_l : (num#num)list) ((i2id i) - start)`));
			thm far = mps(far_merge(), (thm[]){prec1, prec2, prec3, prec4, prec5, prec6, prec7, NULL});
			far = rewrite_rule(symm(I2VI_DEF), far);
			far = rewrite_list_rhs(thl1, far);
			term block1 = `free_area_repr (ifilter inv_l) start end inv_l`;
			term block2 = `store_zero_array (i2vi i) 0 (PAGE_SIZE * (2 EXP ord)) (PAGE_SIZE * (2 EXP ord))`;
			thm sza = rewrite(symm(merge_head_body_axiom()), block2);
			sza = rewrite_rule(hsep_assoc, spec(block1, mp(hsep_cancel_left, eq2ent(sza))));
			sza = once_rewrite_rule(symm(hsep_assoc), sza);
			thm far_sza = rewrite_rule(far, sza);
			
			term *kfactl = (term[]){
				fact_ilen, fact_invl_len, fact_pg_v, 
				fact_ref, fact_ord, fact_ord_lim, 
				fact_ord_norm, fact_ord_align, fact_pc, NULL
			};
			thm *hthl = (thm[]){spa, far_sza, NULL};
			thm trans = create_trans_auto((term[]){NULL}, kfactl, (thm[]){NULL}, hthl);
			trans = point_to_handler(trans, pg2order_axiom, `pg_v : addr`, `&(ord : num)`);
			__transform = which_implies(__state, trans);
		}
		// set_symbolic_state(__transform);
	)]];
	[[cstar::assert(`
	exists pg_v ord i inv_l inv_dl inv_hl buddy_v bi.
		hfact (~(&ord + &1 < &max_order && ~(buddy_v = &0))) **
		hfact ((buddy_v = &0) ||
			~(bi = i) &&
			(buddy_v = vmemmap + &(bi * 4)) &&
			(bi < len) &&
			(REF (nth inv_l bi) = 0) &&
			(ORD (nth inv_l bi) = ord) &&
			((2 EXP (SUC ord)) divides (i2id (MIN i bi))) &&
			(abs (&i - &bi) = &(2 EXP ord))) **
		data_at(&"max_order", Tuchar, &max_order) **
		data_at(&"order", Tuchar, &ord) **
		data_at(&"buddy", Tptr, buddy_v) **
		data_at(&"pool", Tptr, pool_pre) **
		data_at(&"pg", Tptr, pg_v) **
		data_at(&"__hyp_vmemmap", Tptr, vmemmap) **
		hfact (pure_const) **
		hfact (dlist_node pool_pre (ifilter inv_l) inv_l inv_dl inv_hl start end inv_dl) **
		hfact (dlist_head pool_pre inv_l inv_dl 0 max_order inv_hl) **
		hfact (LENGTH inv_l = len) **
		hfact (LENGTH inv_dl = len) **
		hfact (LENGTH inv_hl = max_order) **
		hfact (pg_v = vmemmap + &(i * 4)) **
		hfact (i < len) **
		hfact (~(ord = NO_ORDER)) **
		hfact (ord < max_order) **
		hfact ((2 EXP ord) divides (i2id i)) **
		hfact (ORD (nth inv_l i) = NO_ORDER) **
		hfact (REF (nth inv_l i) = 0) **
		(pool_const pool_pre) **
		(dlist_head_repr pool_pre 0 max_order inv_hl) **
		(free_area_repr (ifilter (modified inv_l i (0, ord))) start end (modified inv_l i (0, ord))) **
		(free_area_head_repr (ifilter inv_l) start end inv_dl) **
		(store_pageinfo_array vmemmap start end (modified inv_l i (0, ord))) **
		data_at(i2vi i, Tptr, &0) **
		data_at(i2vi i + &PTR_SIZE, Tptr, &0)
    `)]];
	[[cstar::argument(
		`pi = i : num`,
		`order_v = ord : num`,
		`vmemmap = vmemmap : addr`,
		`l = inv_l : (num#num)list`,
		`dl = inv_dl : (addr#addr)list`,
		`hl = inv_hl : (addr#addr)list`,
		`start = start : num`,
		`end = end : num`,
		`len = len : num`,
		`max_order = max_order : num`,
		`NO_ORDER = NO_ORDER : num`,
		`PTR_SIZE = PTR_SIZE : num`
	)]]
	page_add_to_list_pool(pool, pg, order);
	[[cstar::assert(`
	exists new_l new_dl new_hl pg_v ord i inv_l (inv_dl : (addr#addr)list) (inv_hl : (addr#addr)list) buddy_v bi.
		hfact (new_l = modified inv_l i (0, ord)) **
		hfact (LENGTH new_l = len) **
		hfact (LENGTH new_dl = len) **
		hfact (LENGTH new_hl = max_order) **
		hfact (~(&ord + &1 < &max_order && ~(buddy_v = &0))) **
		hfact ((buddy_v = &0) ||
			~(bi = i) &&
			(buddy_v = vmemmap + &(bi * 4)) &&
			(bi < len) &&
			(REF (nth inv_l bi) = 0) &&
			(ORD (nth inv_l bi) = ord) &&
			((2 EXP (SUC ord)) divides (i2id (MIN i bi))) &&
			(abs (&i - &bi) = &(2 EXP ord))) **
		data_at(&"max_order", Tuchar, &max_order) **
		data_at(&"order", Tuchar, &ord) **
		data_at(&"buddy", Tptr, buddy_v) **
		data_at(&"pool", Tptr, pool_pre) **
		data_at(&"pg", Tptr, pg_v) **
		data_at(&"__hyp_vmemmap", Tptr, vmemmap) **
		hfact (pure_const) **
		hfact (dlist_node pool_pre (ifilter new_l) new_l new_dl new_hl start end new_dl) **
		hfact (dlist_head pool_pre new_l new_dl 0 max_order new_hl) **
		hfact (LENGTH inv_l = len) **
		hfact (LENGTH inv_dl = len) **
		hfact (LENGTH inv_hl = max_order) **
		hfact (pg_v = vmemmap + &(i * 4)) **
		hfact (i < len) **
		hfact (~(ord = NO_ORDER)) **
		hfact (ord < max_order) **
		hfact ((2 EXP ord) divides (i2id i)) **
		hfact (ORD (nth inv_l i) = NO_ORDER) **
		hfact (REF (nth inv_l i) = 0) **
		(pool_const pool_pre) **
		(dlist_head_repr pool_pre 0 max_order new_hl) **
		(free_area_repr (ifilter (modified inv_l i (0, ord))) start end (modified inv_l i (0, ord))) **
		(free_area_head_repr (ifilter new_l) start end new_dl) **
		(store_pageinfo_array vmemmap start end (modified inv_l i (0, ord)))
    `)]];
	[[cstar::proof(
		/*	proof9 : 
				rewrite with new_l = modified inv_l i (0, ord);
		*/
		// __state = get_symbolic_state();
		{
			term fact = `new_l = modified inv_l i (0, (ord : num))`;
			term far = `free_area_repr (ifilter (modified inv_l i (0, (ord : num)))) start end (modified inv_l i (0, (ord : num)))`;
			term spa = `store_pageinfo_array vmemmap start end (modified inv_l i (0, (ord : num)))`;

			thm far_ent = use_fact_symm_rewrite(fact, far);
			thm spa_ent = use_fact_symm_rewrite(fact, spa);

			thm trans = create_trans_auto((term[]){NULL}, (term[]){fact, NULL}, (thm[]){NULL}, (thm[]){far_ent, spa_ent, NULL});
			__transform = which_implies(__state, trans);
		}
		// set_symbolic_state(__transform);
	)]];
	[[cstar::assert(`
	exists new_l new_dl new_hl pg_v ord i inv_l (inv_dl : (addr#addr)list) (inv_hl : (addr#addr)list) buddy_v bi.
		hfact (new_l = modified inv_l i (0, ord)) **
		hfact (LENGTH new_l = len) **
		hfact (LENGTH new_dl = len) **
		hfact (LENGTH new_hl = max_order) **
		hfact (~(&ord + &1 < &max_order && ~(buddy_v = &0))) **
		hfact ((buddy_v = &0) ||
			~(bi = i) &&
			(buddy_v = vmemmap + &(bi * 4)) &&
			(bi < len) &&
			(REF (nth inv_l bi) = 0) &&
			(ORD (nth inv_l bi) = ord) &&
			((2 EXP (SUC ord)) divides (i2id (MIN i bi))) &&
			(abs (&i - &bi) = &(2 EXP ord))) **
		data_at(&"max_order", Tuchar, &max_order) **
		data_at(&"order", Tuchar, &ord) **
		data_at(&"buddy", Tptr, buddy_v) **
		data_at(&"pool", Tptr, pool_pre) **
		data_at(&"pg", Tptr, pg_v) **
		data_at(&"__hyp_vmemmap", Tptr, vmemmap) **
		hfact (pure_const) **
		hfact (dlist_node pool_pre (ifilter new_l) new_l new_dl new_hl start end new_dl) **
		hfact (dlist_head pool_pre new_l new_dl 0 max_order new_hl) **
		hfact (LENGTH inv_l = len) **
		hfact (LENGTH inv_dl = len) **
		hfact (LENGTH inv_hl = max_order) **
		hfact (pg_v = vmemmap + &(i * 4)) **
		hfact (i < len) **
		hfact (~(ord = NO_ORDER)) **
		hfact (ord < max_order) **
		hfact ((2 EXP ord) divides (i2id i)) **
		hfact (ORD (nth inv_l i) = NO_ORDER) **
		hfact (REF (nth inv_l i) = 0) **
		(pool_const pool_pre) **
		(dlist_head_repr pool_pre 0 max_order new_hl) **
		(free_area_repr (ifilter new_l) start end new_l) **
		(free_area_head_repr (ifilter new_l) start end new_dl) **
		(store_pageinfo_array vmemmap start end new_l)
	`)]];
}

void memset_page_zero(struct hyp_page *pg, u8 order)
	[[cstar::parameter(`i : num`)]]
	[[cstar::parameter(`order_v : num`)]]
	[[cstar::parameter(`vmemmap : addr`)]]
	[[cstar::parameter(`PAGE_SIZE : num`)]]
	[[cstar::require(`
		data_at(&"__hyp_vmemmap", Tptr, vmemmap) **
		hfact(order_v = num_of_int order) **
		hfact (pg = vmemmap + &(i * 4)) **
		(store_undef_array (i2vi i) 0 (PAGE_SIZE * (2 EXP order_v)) (PAGE_SIZE * (2 EXP order_v)))
	`)]]
	[[cstar::ensure(`
		data_at(&"__hyp_vmemmap", Tptr, vmemmap) **
		hfact(order_v = num_of_int order_pre) **
		hfact (pg_pre = vmemmap + &(i * 4)) **
		(store_zero_array (i2vi i) 0 (PAGE_SIZE * (2 EXP order_v)) (PAGE_SIZE * (2 EXP order_v)))
	`)]]
{}

static struct hyp_page *__find_buddy_avail(struct hyp_pool *pool, struct hyp_page *pg, unsigned int order)
	[[cstar::parameter(`pi : num`)]]
	[[cstar::parameter(`order_v : num`)]]
	[[cstar::parameter(`vmemmap : addr`)]]
	[[cstar::parameter(`l : (num#num)list`)]]
	[[cstar::parameter(`start : num`)]]
	[[cstar::parameter(`end : num`)]]
	[[cstar::parameter(`len : num`)]]
	[[cstar::require(`
		data_at(&"__hyp_vmemmap", Tptr, vmemmap) **
		hfact (order_v = num_of_int order) **
		(pool_const pool) **
		store_pageinfo_array vmemmap start end l **
		hfact (LENGTH l = len) **
		hfact (pg = vmemmap + &(i * 4)) **
		hfact (pi < len) **
		hfact ((2 EXP order_v) divides (i2id pi))
	`)]]
	[[cstar::ensure(`
	exists buddy bi.
		data_at(&"__hyp_vmemmap", Tptr, vmemmap) **
		hfact(order_v = num_of_int order_pre) **
		hfact ((__result = &0) ||
			~(bi = pi) &&
			(__result = vmemmap + &(bi * 4)) &&
			(bi < len) &&
			(REF (nth l bi) = 0) &&
			(ORD (nth l bi) = order_v) &&
			((2 EXP (SUC order_v)) divides (i2id (MIN pi bi))) &&
			(abs (&pi - &bi) = &(2 EXP order_v))) **
		(pool_const pool_pre) **
		store_pageinfo_array vmemmap start end l **
		hfact (LENGTH l = len) **
		hfact (pg_pre = vmemmap + &(pi * 4)) **
		hfact (pi < len) **
		hfact ((2 EXP order_v) divides (i2id pi))
	`)]]
{}

void page_remove_from_list_pool(struct hyp_pool *pool, struct hyp_page *pg)
	[[cstar::parameter(`pi : num`)]]
	[[cstar::parameter(`order : num`)]]	
	[[cstar::parameter(`vmemmap : addr`)]]
	[[cstar::parameter(`l : (num#num)list`)]]	
	[[cstar::parameter(`dl : (addr#addr)list`)]]	
	[[cstar::parameter(`hl : (addr#addr)list`)]]
	[[cstar::parameter(`start : num`)]]
	[[cstar::parameter(`end : num`)]]
	[[cstar::parameter(`len : num`)]]
	[[cstar::parameter(`max_order : num`)]]
	[[cstar::parameter(`NO_ORDER : num`)]]
	[[cstar::parameter(`PTR_SIZE : num`)]]
	[[cstar::require(`
		data_at(&"__hyp_vmemmap", Tptr, vmemmap) **
		hfact (pure_const) **
		hfact (LENGTH l = len) **
		hfact (LENGTH dl = len) **
		hfact (LENGTH hl = max_order) **
		hfact (pg = vmemmap + &(pi * 4)) **
		hfact (pi < len) **
		hfact (ORD (nth l pi) = order) **
		hfact (REF (nth l pi) = 0) **
		hfact (order < max_order) **
		hfact (dlist_node pool (ifilter l) l dl hl start end dl) **
		hfact (dlist_head pool l dl 0 max_order hl) **
		(dlist_head_repr pool 0 max_order hl) **
		(free_area_head_repr (ifilter l) start end dl)
	`)]]
	[[cstar::ensure(`
	exists new_l new_dl new_hl.
		data_at(&"__hyp_vmemmap", Tptr, vmemmap) **
		hfact (new_l = modified l pi (0, NO_ORDER)) **
		hfact (pure_const) **
		hfact (LENGTH l = len) **
		hfact (LENGTH dl = len) **
		hfact (LENGTH hl = max_order) **
		hfact (LENGTH new_l = len) **
		hfact (LENGTH new_dl = len) **
		hfact (LENGTH new_hl = max_order) **
		hfact (pg_pre = vmemmap + &(pi * 4)) **
		hfact (pi < len) **
		hfact (ORD (nth l pi) = order) **
		hfact (REF (nth l pi) = 0) **
		hfact (order < max_order) **
		hfact (dlist_node pool_pre (ifilter new_l) new_l new_dl new_hl start end new_dl) **
		hfact (dlist_head pool_pre new_l new_dl 0 max_order new_hl) **
		(dlist_head_repr pool_pre 0 max_order new_hl) **
		(free_area_head_repr (ifilter new_l) start end new_dl) **
		(data_at (i2vi pi, Tptr, &0)) **
		(data_at (i2vi pi + &PTR_SIZE, Tptr, &0))
	`)]]
{}

void page_add_to_list_pool(struct hyp_pool *pool, struct hyp_page *pg, u8 order)
	[[cstar::parameter(`pi : num`)]]
	[[cstar::parameter(`order_v : num`)]]	
	[[cstar::parameter(`vmemmap : addr`)]]
	[[cstar::parameter(`l : (num#num)list`)]]	
	[[cstar::parameter(`dl : (addr#addr)list`)]]	
	[[cstar::parameter(`hl : (addr#addr)list`)]]
	[[cstar::parameter(`start : num`)]]
	[[cstar::parameter(`end : num`)]]
	[[cstar::parameter(`len : num`)]]
	[[cstar::parameter(`max_order : num`)]]
	[[cstar::parameter(`NO_ORDER : num`)]]	
	[[cstar::parameter(`PTR_SIZE : num`)]]
	[[cstar::require(`
		data_at(&"__hyp_vmemmap", Tptr, vmemmap) **
		hfact (order_v = num_of_int order) **
		hfact (pure_const) **
		hfact (LENGTH l = len) **
		hfact (LENGTH dl = len) **
		hfact (LENGTH hl = max_order) **
		hfact (pg = vmemmap + &(pi * 4)) **
		hfact (pi < len) **
		hfact (ORD (nth l pi) = NO_ORDER) **
		hfact (REF (nth l pi) = 0) **
		hfact (order_v < max_order) **
		hfact (dlist_node pool (ifilter l) l dl hl start end dl) **
		hfact (dlist_head pool l dl 0 max_order hl) **
		(dlist_head_repr pool 0 max_order hl) **
		(free_area_head_repr (ifilter l) start end dl) **
		(data_at (i2vi pi, Tptr, &0)) **
		(data_at (i2vi pi + &PTR_SIZE, Tptr, &0))
	`)]]
	[[cstar::ensure(`
	exists new_l new_dl new_hl.
		data_at(&"__hyp_vmemmap", Tptr, vmemmap) **
		hfact (pool == pool_pre) **
		hfact (pg == pg_pre) **
		hfact (order_v = num_of_int order_pre) **
		hfact (new_l = modified l pi (0, order_v)) **
		hfact (pure_const) **
		hfact (LENGTH l = len) **
		hfact (LENGTH dl = len) **
		hfact (LENGTH hl = max_order) **
		hfact (LENGTH new_l = len) **
		hfact (LENGTH new_dl = len) **
		hfact (LENGTH new_hl = max_order) **
		hfact (pg_pre = vmemmap + &(pi * 4)) **
		hfact (pi < len) **
		hfact (ORD (nth l pi) = NO_ORDER) **
		hfact (REF (nth l pi) = 0) **
		hfact (order_v < max_order) **
		hfact (dlist_node pool_pre (ifilter new_l) new_l new_dl new_hl start end new_dl) **
		hfact (dlist_head pool_pre new_l new_dl 0 max_order new_hl) **
		(dlist_head_repr pool_pre 0 max_order new_hl) **
		(free_area_head_repr (ifilter new_l) start end new_dl)
	`)]]
{}