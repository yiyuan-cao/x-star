typedef const struct Gc_Term *term;
typedef const struct Gc_Theorem *thm;

[[cstar::function(
thm array_at_zero_length(term t1, term t2, term t3) { 
  thm array_at_zero_length = symm(get_theorem("array_at_replicate_zero_length"));
  return spec(t3, spec(t2, spec(t1, array_at_zero_length)));
}
)]];

[[cstar::function(
thm add_emp_equiv_right(thm th, term state) {
  thm hentail_sym_left = get_theorem("hentail_sym_left");
  thm hsep_hemp_right = spec(state, symm(get_theorem("hsep_hemp_right")));
  thm result = mp(hentail_sym_left, hsep_hemp_right);
  result = sep_normalize_rule(rewrite_rule(th, result));
  return result;
}
)]];

[[cstar::function(
thm array_at_last_split(term t1, term t2, term t3, term t4) {
  return spec(t4, spec(t3, spec(t2, spec(t1, get_theorem("array_at_last_split")))));
}
)]];

[[cstar::function(
thm undef_array_at_select_first(term t1, term t2, term t3) {
  thm undef_array_at_rec_def = get_theorem("undef_array_at_rec_def");
  thm result = spec(t3, spec(t2, spec(t1, undef_array_at_rec_def)));
  result = mp(get_theorem("hentail_sym_left"), undisch(result));
  return disch(result, hypth(result));
}
)]];

[[cstar::function(
thm hsep_monotone(thm th1, thm th2) {
  return sep_normalize_rule(mp(mp(get_theorem("hsep_monotone"), th1), th2));
}
)]];

[[cstar::function(
thm undef_array_at_zero_length(term t1, term t2) {
  return mp(get_theorem("hentail_sym_left"), 
      spec(t2, spec(t1, get_theorem("undef_array_at_zero_length"))));
}
)]];

[[cstar::function(
thm hfact_manual(term pre1, term pre2, term post) {
  thm arith = undisch(undisch(arith_rule(`${pre1:bool} ==> ${pre2:bool} ==> ${post:bool}`)));
  thm result = spec(`emp`, get_theorem("hentail_refl"));
  result = mp(mp(get_theorem("hfact_intro"), arith), result);
  result = mp(get_theorem("hfact_elim"), disch(result, hypth(result)));
  result = mp(get_theorem("hfact_elim"), disch(result, hypth(result)));
  return sep_normalize_rule(result);
}
)]];

void clear(void *to, int len)
    [[cstar::parameter(`n:int`)]]
    [[cstar::require(`fact(n >= &0) ** fact(len == n) ** undef_array_at(to, Tchar, n)`)]]
    [[cstar::ensure(`array_at(to, Tchar, replicate(len, &0))`)]]
{
  [[cstar::proof(
    term unmodified = `data_at(&"to", Tptr, to_pre) **
                       data_at(&"len", Tint, n)`;
  )]];

  [[cstar::assert(`
      fact(n >= &0) **
      ${unmodified:hprop} **
      undef_array_at(to_pre, Tchar, n) 
  `)]];

  int i = 0;

  [[cstar::assert(`
    fact(n >= &0) ** 
    data_at(&"i", Tint, &0) **
    ${unmodified:hprop} **
    undef_array_at(to_pre, Tchar, n)
  `)]];

  [[cstar::proof(
    { /* transform to a suitable invariant */
      term pre_state = get_symbolic_state();
      thm emp_equiv_thm = array_at_zero_length(`to_pre:int`, `Tchar`, `&0:int`);
      /* |- emp -|- array_at(to@pre, Tchar, replicate(&0, &0)) */
      thm final_thm = add_emp_equiv_right(emp_equiv_thm, pre_state);
      /* |- {$pre_state} |-- {$pre_state} ** array_at(to@pre, Tchar, replicate(&0, &0)) */
      set_symbolic_state(sep_normalize_rule(final_thm));
    }
  )]]; 

  [[cstar::assert(`
    fact(n >= &0) ** 
    data_at(&"i", Tint, &0) **
    ${unmodified:hprop} **
    undef_array_at(to_pre, Tchar, n) **
    array_at(to_pre, Tchar, replicate(&0, &0))
  `)]];

  [[cstar::proof(
    {
      term pre_state = get_symbolic_state();
      thm hfact_thm = hfact_auto((term[]) {`n >= &0`, NULL},
                                 (term[]) {`n >= &0`, `&0 <= &0`, `&0 <= n`, NULL}, (thm[]){NULL});
      /* |- n >= &0 ==> (emp |-- fact(&0 <= &0) ** fact(&0 <= n)) */
      thm undef_array_simpl = 
        mp(get_theorem("hentail_sym_left"), symm(
          rewrite_list((thm[]){ arith_rule(`to_pre + &0 * sizeof(Tchar) = to_pre`),
                                arith_rule(`n - &0 = n`),
                                NULL },
                      `undef_array_at(to_pre + &0 * sizeof(Tchar), Tchar, n - &0)`)));
      thm hsep_mono = hsep_monotone(hfact_thm, undef_array_simpl);
      thm final_thm = which_implies(pre_state, hsep_mono);
      set_symbolic_state(final_thm);
    }
  )]];

  [[cstar::assert(`
    fact(&0 <= &0) ** fact(&0 <= n) **
    fact(n >= &0) **
    data_at(&"i", Tint, &0) **
    ${unmodified:hprop} **
    array_at(to_pre, Tchar, replicate(&0, &0)) **
    undef_array_at(to_pre + &0 * sizeof(Tchar), Tchar, n - &0)
  `)]];

  while (i < len)
    [[cstar::invariant(`
        exists (i_v:int).
        fact(&0 <= i_v) ** fact(i_v <= n) **
        data_at(&"i", Tint, i_v) **
        ${unmodified:hprop} **
        array_at(to_pre, Tchar, replicate(i_v, &0)) ** 
        undef_array_at(to_pre + i_v * sizeof(Tchar), Tchar, n - i_v)
    `)]]
  {
    [[cstar::assert(`
        exists (i_v:int).
        fact(i_v < n) ** 
        fact(&0 <= i_v) ** fact(i_v <= n) ** 
        fact(n >= &0) **
        data_at(&"i", Tint, i_v) **
        ${unmodified:hprop} **
        array_at(to_pre, Tchar, replicate(i_v, &0)) **
        undef_array_at(to_pre + i_v * sizeof(Tchar), Tchar, n - i_v)
    `)]];

    [[cstar::proof(
      {
        thm dest_undef_array =
        undef_array_at_select_first(`to + i * sizeof(Tchar)`, `Tchar`, `len - i`);
        /* len - i > 0 ==>
           undef_array_at(to + i * sizeof(Tchar), Tchar, len - i) 
           |--
           undef_data_at(to + i * sizeof(Tchar), Tchar) **
           undef_array_at((to + i * sizeof(Tchar)) + sizeof(Tchar), Tchar, len - i - 1) */
        thm* arith_facts = (thm[]){
            arith_rule(`len - i > &0 <=> i < len`),
            arith_rule(`len - i - 1 == len - (i + &1)`),
            arith_rule(`(to + i * sizeof(Tchar)) + sizeof(Tchar) ==
                        to + (i + &1) * sizeof(Tchar)`),
            NULL
        };
        dest_undef_array = rewrite_rule_list(arith_facts, dest_undef_array);
        /* rewrite using linear arithmetic facts */
        thm final_thm = which_implies(get_symbolic_state(), dest_undef_array);
        /* perform local transformation with frame inferred from the symbolic state */
        set_symbolic_state(final_thm);
        /* update the symbolic state */
      }
    )]];

    [[cstar::assert(`
        exists (i_v:int).
        fact(i_v < n) ** 
        fact(&0 <= i_v) ** fact(i_v <= n) ** 
        fact(n >= &0) **
        data_at(&"i", Tint, i_v) **
        ${unmodified:hprop} ** 
        array_at(to_pre, Tchar, replicate(i_v, &0)) **
        undef_data_at(to_pre + i_v * sizeof(Tchar), Tchar) **
        undef_array_at(to_pre + (i_v + &1) * sizeof(Tchar), Tchar, n - (i_v + 1))
    `)]];
    
    *((char *)to + i) = (char) 0;

    [[cstar::assert(`
        exists (i_v:int).
        fact(i_v < n) ** 
        fact(&0 <= i_v) ** fact(i_v <= n) ** 
        fact(n >= &0) **
        data_at(&"i", Tint, i_v) **
        ${unmodified:hprop} ** 
        array_at(to_pre, Tchar, replicate(i_v, &0)) **
        data_at(to_pre + i_v * sizeof(Tchar), Tchar, &0) **
        undef_array_at(to_pre + (i_v + &1) * sizeof(Tchar), Tchar, n - (i_v + &1))
    `)]];

    i = i + 1;

    [[cstar::assert(`
        exists (i_v:int).
        fact(i_v < n) ** 
        fact(&0 <= i_v) ** fact(i_v <= n) ** 
        fact(n >= &0) **
        data_at(&"i", Tint, i_v + &1) **
        ${unmodified:hprop} ** 
        array_at(to_pre, Tchar, replicate(i_v, &0)) **
        data_at(to_pre + i_v * sizeof(Tchar), Tchar, &0) **
        undef_array_at(to_pre + (i_v + &1) * sizeof(Tchar), Tchar, n - (i_v + &1))
    `)]];

    [[cstar::proof(
      {
        term pre_state = get_symbolic_state();
        thm array_at_last = array_at_last_split(`to_pre:int`, `Tchar`, `&0`, `i_v:int`);
        array_at_last = rewrite_rule(arith_rule(`(i_v >= &0) <=> (&0 <= i_v)`), array_at_last);
        thm final_thm = which_implies(pre_state, array_at_last);
        set_symbolic_state(final_thm);
      }
    )]];

    [[cstar::assert(`
        exists (i_v:int).
        fact(i_v < n) ** 
        fact(&0 <= i_v) ** fact(i_v <= n) ** 
        fact(n >= &0) **
        data_at(&"i", Tint, i_v + &1) **
        ${unmodified:hprop} ** 
        array_at(to_pre, Tchar, replicate(i_v + &1, &0)) **
        undef_array_at(to_pre + (i_v + &1) * sizeof(Tchar), Tchar, n - (i_v + &1))
    `)]];

    [[cstar::proof(
      {
        term pre_state = get_symbolic_state();
        thm hfact_thm = hfact_auto((term[]){`n >= &0`, `i_v < n`, `&0 <= i_v`, `i_v <= n`, NULL},
                                   (term[]){`n >= &0`, `i_v + &1 <= n`, `&0 <= i_v + &1`, NULL},
                                   (thm[]){NULL});
        thm final_thm = which_implies(pre_state, hfact_thm);
        set_symbolic_state(final_thm);
      }
    )]];

    [[cstar::assert(`
        exists (i_v:int).
        fact(&0 <= i_v + &1) ** (i_v + &1 <= n) **
        fact(n >= &0) **
        data_at(&"i", Tint, i_v + &1) **
        ${unmodified:hprop} ** 
        array_at(to_pre, Tchar, replicate(i_v + &1, &0)) **
        undef_array_at(to_pre + (i_v + &1) * sizeof(Tchar), Tchar, n - (i_v + 1))
    `)]];
  }

  [[cstar::assert(`
      exists (i_v:int).
      fact(i_v >= (n:int)) ** 
      fact(&0 <= i_v) ** fact(i_v <= n) ** 
      fact(n >= &0) **
      data_at(&"i", Tint, i_v) **
      ${unmodified:hprop} ** 
      array_at(to_pre, Tchar, replicate(i_v, &0)) **
      undef_array_at(to_pre + i_v * sizeof(Tchar), Tchar, n - i_v)
  `)]];

  [[cstar::proof(
    tmp_term = 
      normalize
      (`fact(n >= &0) ** fact (&0 <= i_v) **
        data_at(&"i", Tint, i_v) **
        ${unmodified:hprop} ** 
        array_at(to_pre, Tchar, replicate(i_v, &0)) **
        undef_array_at(to_pre + i_v * sizeof(Tchar), Tchar, n - i_v)`);
    {
      term pre_state = get_symbolic_state();
      thm hfact1 = hfact_manual(`(i_v:int) >= n`, `(i_v:int) <= n`, `(i_v:int) == n`);
      hfact1 = which_implies(normalize(binder_body("hexists", pre_state)), hfact1);

      thm subst_i_v = mp(get_theorem("hentail_sym_left"), 
        rewrite(assume(`(i_v:int) = n`), tmp_term));
      subst_i_v = mp(get_theorem("hfact_elim"), disch(subst_i_v, hypth(subst_i_v)));

      thm hfact2 = hfact_auto((term[]){`n >= &0`, `&0 <= n`, NULL},
                              (term[]){`n >= &0`, NULL}, (thm[]){NULL});
      hfact2 = which_implies(consequent(conclusion(subst_i_v)), hfact2);

      thm without_exists = hentail_trans_auto_list((thm[]){hfact1, subst_i_v, hfact2, NULL});
      thm final_thm = mp(get_theorem("hexists_elim"), gen(`i_v:int`, without_exists));
      set_symbolic_state(final_thm);
    }
  )]];

  [[cstar::assert(`
      fact(n >= &0) **
      data_at(&"i", Tint, n) **
      ${unmodified:hprop} ** 
      array_at(to_pre, Tchar, replicate(n, &0)) **
      undef_array_at(to_pre + n * sizeof(Tchar), Tchar, n - n)
  `)]];

  [[cstar::proof(
    {
      term pre_state = get_symbolic_state();
      thm undef_array_elim = undef_array_at_zero_length(`to_pre + n * sizeof(Tchar)`, `Tchar`);
      undef_array_elim = rewrite_rule(arith_rule(`&0 = (n:int) - n`), undef_array_elim);
      thm final_thm = which_implies(pre_state, undef_array_elim);
      set_symbolic_state(final_thm);
    }
  )]];

  [[cstar::assert(`
      fact(n >= &0) **
      data_at(&"i", Tint, n) **
      ${unmodified:hprop} ** 
      array_at(to_pre, Tchar, replicate(n, &0))
  `)]];

}

